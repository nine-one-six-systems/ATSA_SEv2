---
phase: 01-core-calculation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - database/init_db.py
  - models/joint_analysis.py
  - models/__init__.py
autonomous: true

must_haves:
  truths:
    - "Database operations complete without 'database locked' errors during concurrent access"
    - "JointAnalysisSummary table exists in database"
    - "Model can be imported from models module"
  artifacts:
    - path: "database/init_db.py"
      provides: "SQLite WAL mode and busy timeout configuration"
      contains: "PRAGMA journal_mode=WAL"
    - path: "models/joint_analysis.py"
      provides: "JointAnalysisSummary model definition"
      min_lines: 80
      exports: ["JointAnalysisSummary"]
    - path: "models/__init__.py"
      provides: "JointAnalysisSummary import and export"
      contains: "from models.joint_analysis import JointAnalysisSummary"
  key_links:
    - from: "models/__init__.py"
      to: "models/joint_analysis.py"
      via: "import statement"
      pattern: "from models\\.joint_analysis import"
    - from: "database/init_db.py"
      to: "models.joint_analysis"
      via: "db.create_all() discovers model"
      pattern: "from models\\.joint_analysis"
---

<objective>
Establish database infrastructure and data model for dual-filer joint analysis, preventing concurrency issues and providing storage for MFJ/MFS comparison results.

Purpose: Phase 1 requires concurrent write access (both spouses analyzed simultaneously) and a model to cache joint analysis results. SQLite WAL mode enables multiple writers without "database locked" errors. JointAnalysisSummary stores MFJ totals, MFS totals per spouse, and comparison data.

Output: SQLite configured for concurrency, JointAnalysisSummary model created and registered, database ready for dual-filer writes.
</objective>

<execution_context>
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/workflows/execute-plan.md
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/samueledwards/ATSA_SEv2/.planning/PROJECT.md
@/Users/samueledwards/ATSA_SEv2/.planning/ROADMAP.md
@/Users/samueledwards/ATSA_SEv2/.planning/STATE.md
@/Users/samueledwards/ATSA_SEv2/.planning/REQUIREMENTS.md
@/Users/samueledwards/ATSA_SEv2/.planning/LEARNINGS.md
@/Users/samueledwards/ATSA_SEv2/.planning/phases/01-core-calculation-engine/01-RESEARCH.md

# Patterns to follow
@/Users/samueledwards/ATSA_SEv2/models/analysis.py
@/Users/samueledwards/ATSA_SEv2/models/__init__.py
@/Users/samueledwards/ATSA_SEv2/database/init_db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable SQLite WAL Mode</name>
  <files>database/init_db.py</files>
  <action>
  Modify init_database() function to enable SQLite Write-Ahead Logging mode immediately after db.create_all().

  1. Add import at top: `from sqlalchemy import text`
  2. After line 13 (db.create_all()), add:
     ```python
     # Enable WAL mode for concurrent reads + writes (REQ-12)
     # Prevents "database locked" errors with dual-filer pattern
     db.session.execute(text("PRAGMA journal_mode=WAL"))
     db.session.execute(text("PRAGMA busy_timeout=30000"))  # 30 second timeout
     db.session.commit()
     ```
  3. Add comment explaining why: dual-filer = 2x write frequency, WAL enables multiple writers

  DO NOT modify existing seed_irs_references() or populate_tax_tables() calls.
  DO use text() wrapper for PRAGMA statements (SQLAlchemy 2.x requirement).

  Why WAL mode: Default SQLite mode = single writer. Dual-filer analysis can have concurrent writes (husband analysis + wife document upload). WAL mode allows unlimited readers + multiple writers with short transactions.

  Why 30-second timeout: Gives long-running analysis time to complete without blocking other operations. If timeout occurs, error surfaces to user rather than silent failure.
  </action>
  <verify>
  Run: `python -c "from database.init_db import init_database; from models import db; from app import app; app.app_context().push(); init_database(); result = db.session.execute(text('PRAGMA journal_mode')).fetchone(); print('Journal mode:', result[0])"`

  Expected output: "Journal mode: wal"
  </verify>
  <done>
  - init_db.py contains PRAGMA journal_mode=WAL after db.create_all()
  - init_db.py contains PRAGMA busy_timeout=30000
  - Running init_database() sets SQLite to WAL mode
  - Comment explains dual-filer concurrency rationale
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JointAnalysisSummary Model</name>
  <files>models/joint_analysis.py</files>
  <action>
  Create new model file following AnalysisSummary pattern from models/analysis.py.

  1. Create models/joint_analysis.py with imports:
     ```python
     from models import db
     from datetime import datetime
     import json
     ```

  2. Define JointAnalysisSummary model with fields (REQ-13):
     - id (Integer, primary_key)
     - spouse1_id (Integer, ForeignKey('clients.id'), nullable=False)
     - spouse2_id (Integer, ForeignKey('clients.id'), nullable=False)
     - tax_year (Integer, nullable=True)

     # MFJ scenario fields
     - mfj_combined_income (Float, default=0)
     - mfj_agi (Float, default=0)
     - mfj_taxable_income (Float, default=0)
     - mfj_total_tax (Float, default=0)
     - mfj_effective_rate (Float, default=0)
     - mfj_standard_deduction (Float, default=0)

     # MFS scenario fields
     - mfs_spouse1_income (Float, default=0)
     - mfs_spouse1_agi (Float, default=0)
     - mfs_spouse1_taxable_income (Float, default=0)
     - mfs_spouse1_tax (Float, default=0)
     - mfs_spouse2_income (Float, default=0)
     - mfs_spouse2_agi (Float, default=0)
     - mfs_spouse2_taxable_income (Float, default=0)
     - mfs_spouse2_tax (Float, default=0)
     - mfs_combined_tax (Float, default=0)
     - mfs_effective_rate (Float, default=0)
     - mfs_standard_deduction (Float, default=0)  # Per spouse

     # Comparison fields
     - recommended_status (String(20))  # 'MFJ' or 'MFS'
     - savings_amount (Float, default=0)  # Positive = MFJ saves money
     - comparison_notes (Text, nullable=True)  # JSON array of notes

     # Caching fields
     - data_version_hash (String(64))  # Combined hash from both spouses
     - last_analyzed_at (DateTime, default=datetime.utcnow)
     - created_at (DateTime, default=datetime.utcnow)
     - updated_at (DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

  3. Add unique constraint:
     ```python
     __table_args__ = (
         db.UniqueConstraint('spouse1_id', 'spouse2_id', name='unique_spouse_pair'),
     )
     ```

  4. Add to_dict() method following pattern from models/analysis.py lines 27-54:
     - Parse comparison_notes from JSON if exists
     - Return nested structure: mfj {...}, mfs {...}, comparison {...}
     - Include timestamps in ISO format

  DO follow AnalysisSummary structure exactly (same field types, default values, datetime handling).
  DO use Float for all currency amounts (consistent with existing models).
  DO NOT add relationships to Client model yet (service layer will query directly).

  Why unique constraint: Prevents duplicate joint analyses for same spouse pair. Only one cached result per couple.

  Why combined_income separate from spouse1+spouse2: MFJ may have joint income sources (e.g., joint investment account) not attributable to one spouse. Phase 2 will handle this.
  </action>
  <verify>
  Run: `python -c "from models.joint_analysis import JointAnalysisSummary; print('Model fields:', [c.name for c in JointAnalysisSummary.__table__.columns]); print('Has to_dict:', hasattr(JointAnalysisSummary, 'to_dict'))"`

  Expected: List of field names including mfj_combined_income, mfs_spouse1_tax, recommended_status, data_version_hash. Has to_dict: True.
  </verify>
  <done>
  - models/joint_analysis.py exists with JointAnalysisSummary class
  - Model has all MFJ scenario fields (6 fields)
  - Model has all MFS scenario fields (10 fields)
  - Model has comparison fields (3 fields)
  - Model has caching fields (4 fields)
  - Unique constraint on (spouse1_id, spouse2_id)
  - to_dict() method returns nested structure
  </done>
</task>

<task type="auto">
  <name>Task 3: Register JointAnalysisSummary Model</name>
  <files>models/__init__.py</files>
  <action>
  Register new model following pattern from models/__init__.py lines 1-14.

  1. Add import after line 11 (after AnalysisResult, AnalysisSummary import):
     `from models.joint_analysis import JointAnalysisSummary`

  2. Add to __all__ list after 'AnalysisSummary':
     `'JointAnalysisSummary'`

  DO maintain alphabetical order within each section (models after db, standard models before JointAnalysisSummary).
  DO NOT modify existing imports or db initialization.

  Why this matters: db.create_all() in init_db.py discovers models through models/__init__.py imports. Without this import, table won't be created.
  </action>
  <verify>
  Run: `python -c "from models import JointAnalysisSummary; print('Import successful'); print('Table name:', JointAnalysisSummary.__tablename__)"`

  Expected: "Import successful" and "Table name: joint_analysis_summaries"
  </verify>
  <done>
  - models/__init__.py imports JointAnalysisSummary
  - models/__init__.py exports JointAnalysisSummary in __all__
  - Import is placed after AnalysisSummary import
  - Can import JointAnalysisSummary from models module
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Run full database initialization:
   ```bash
   python -c "from app import app; from database.init_db import init_database; app.app_context().push(); init_database()"
   ```

2. Verify WAL mode enabled:
   ```bash
   sqlite3 instance/tax_analyzer.db "PRAGMA journal_mode"
   ```
   Expected: "wal"

3. Verify table created:
   ```bash
   sqlite3 instance/tax_analyzer.db ".schema joint_analysis_summaries"
   ```
   Expected: CREATE TABLE statement with all 23 fields

4. Verify model import:
   ```python
   from models import JointAnalysisSummary
   summary = JointAnalysisSummary(spouse1_id=1, spouse2_id=2)
   print(summary.to_dict())
   ```
   Expected: Dictionary with mfj, mfs, comparison keys
</verification>

<success_criteria>
1. SQLite database operates in WAL mode (verified via PRAGMA journal_mode query returning "wal")
2. JointAnalysisSummary model can be imported from models module
3. Database contains joint_analysis_summaries table with 23 fields
4. Model instantiation works: `JointAnalysisSummary(spouse1_id=1, spouse2_id=2).to_dict()` returns nested structure
5. Concurrent database access does not produce "database locked" errors (testable in Plan 02 when service writes results)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-calculation-engine/01-01-SUMMARY.md`
</output>
