---
phase: 01-core-calculation-engine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - services/joint_analysis_service.py
  - services/analysis_engine.py
autonomous: true

must_haves:
  truths:
    - "Joint analysis can be triggered for two linked spouses and returns MFJ + MFS results"
    - "MFJ calculation uses combined income through married_joint brackets"
    - "MFS calculation uses separate incomes through married_separate brackets"
    - "Changing either spouse's data invalidates both individual and joint cached analyses"
  artifacts:
    - path: "services/joint_analysis_service.py"
      provides: "Joint analysis orchestration service"
      min_lines: 200
      exports: ["JointAnalysisService"]
    - path: "services/analysis_engine.py"
      provides: "Extended hash calculation with spouse data"
      contains: "if client and client.spouse_id:"
  key_links:
    - from: "services/joint_analysis_service.py"
      to: "services.analysis_engine.AnalysisEngine"
      via: "analyze_client() calls"
      pattern: "AnalysisEngine\\.analyze_client"
    - from: "services/joint_analysis_service.py"
      to: "services.tax_calculator.TaxCalculator"
      via: "bracket lookups for MFJ/MFS"
      pattern: "TaxCalculator\\.(get_tax_brackets|calculate_tax_by_brackets)"
    - from: "services/analysis_engine.py"
      to: "models.Client"
      via: "spouse_id relationship query"
      pattern: "client\\.spouse_id"
---

<objective>
Build JointAnalysisService that orchestrates dual-filer analysis by coordinating existing TaxCalculator and AnalysisEngine to produce MFJ and MFS tax scenarios with accurate standard deductions and bidirectional cache invalidation.

Purpose: This is the core calculation engine for Phase 1. Service layer handles business logic (combining two analyses, calculating scenarios, generating comparison), delegating to existing tax calculation components. Bidirectional cache invalidation ensures either spouse's data change triggers fresh joint analysis.

Output: Working joint analysis service that accepts two spouse IDs, returns structured comparison with MFJ totals, MFS totals per spouse, and dollar savings recommendation.
</objective>

<execution_context>
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/workflows/execute-plan.md
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/samueledwards/ATSA_SEv2/.planning/PROJECT.md
@/Users/samueledwards/ATSA_SEv2/.planning/ROADMAP.md
@/Users/samueledwards/ATSA_SEv2/.planning/REQUIREMENTS.md
@/Users/samueledwards/ATSA_SEv2/.planning/LEARNINGS.md
@/Users/samueledwards/ATSA_SEv2/.planning/phases/01-core-calculation-engine/01-RESEARCH.md

# Service patterns
@/Users/samueledwards/ATSA_SEv2/services/analysis_engine.py
@/Users/samueledwards/ATSA_SEv2/services/tax_calculator.py

# Models needed
@/Users/samueledwards/ATSA_SEv2/models/client.py
@/Users/samueledwards/ATSA_SEv2/models/analysis.py
@/Users/samueledwards/ATSA_SEv2/models/joint_analysis.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend AnalysisEngine for Bidirectional Cache Invalidation</name>
  <files>services/analysis_engine.py</files>
  <action>
  Modify _calculate_data_version_hash() to include spouse's ExtractedData when spouse_id exists (REQ-08).

  1. In _calculate_data_version_hash() method (currently lines 14-35), after line 24 (extracting client data):
     ```python
     # REQ-08: Include spouse data for bidirectional cache invalidation
     # When either spouse's data changes, both individual analyses refresh
     client = Client.query.get(client_id)
     if client and client.spouse_id:
         spouse_data = ExtractedData.query.filter_by(client_id=client.spouse_id).all()
         extracted_data.extend(spouse_data)
     ```

  2. Add docstring note explaining behavior:
     ```python
     """
     Calculate a hash of all ExtractedData timestamps for a client to detect data changes

     IMPORTANT (REQ-08): If client has spouse_id, spouse's data is ALSO included in hash.
     This ensures:
     - Changing wife's data invalidates husband's cached analysis
     - Changing husband's data invalidates wife's cached analysis

     Rationale: Joint analysis depends on both spouses, so individual analyses
     should refresh when either spouse's data changes.

     Args:
         client_id: ID of the client

     Returns:
         str: SHA-256 hash of sorted timestamps (including spouse if linked)
     """
     ```

  DO place spouse data inclusion BEFORE the "if not extracted_data" check (line 26).
  DO extend the existing extracted_data list (don't replace it).
  DO NOT modify hash calculation logic (lines 29-35).

  Why this matters: Without spouse data in hash, changing wife's W-2 wouldn't invalidate husband's cached individual analysis, leading to stale individual summaries when viewing split-screen UI. With spouse data included, both refresh automatically.

  Trade-off: More frequent recalculations (wife's change refreshes husband's analysis) vs correctness. We choose correctness over performance.
  </action>
  <verify>
  Run test:
  ```python
  from app import app
  from services.analysis_engine import AnalysisEngine
  from models import Client, ExtractedData, db

  app.app_context().push()

  # Create two linked clients
  spouse1 = Client(first_name="John", last_name="Doe", filing_status="married_joint")
  db.session.add(spouse1)
  db.session.commit()

  spouse2 = Client(first_name="Jane", last_name="Doe", filing_status="married_joint", spouse_id=spouse1.id)
  db.session.add(spouse2)
  spouse1.spouse_id = spouse2.id
  db.session.commit()

  # Calculate hash for spouse1 (should be empty)
  hash1 = AnalysisEngine._calculate_data_version_hash(spouse1.id)

  # Add data to spouse2
  data = ExtractedData(client_id=spouse2.id, form_type="W-2", field_name="wages", field_value="50000")
  db.session.add(data)
  db.session.commit()

  # Recalculate hash for spouse1 (should change because spouse2 has new data)
  hash2 = AnalysisEngine._calculate_data_version_hash(spouse1.id)

  print("Hash changed:", hash1 != hash2)
  ```
  Expected: "Hash changed: True"
  </verify>
  <done>
  - _calculate_data_version_hash() includes spouse ExtractedData when spouse_id exists
  - Docstring explains bidirectional invalidation rationale
  - Hash changes when spouse's data changes (verified via test)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JointAnalysisService with MFJ Calculation</name>
  <files>services/joint_analysis_service.py</files>
  <action>
  Create service orchestrating joint analysis following pattern from services/analysis_engine.py.

  1. Create services/joint_analysis_service.py with imports:
     ```python
     from models import db, Client, JointAnalysisSummary
     from services.analysis_engine import AnalysisEngine
     from services.tax_calculator import TaxCalculator
     from decimal import Decimal, ROUND_HALF_UP
     import hashlib
     from datetime import datetime
     ```

  2. Create JointAnalysisService class with helper method _calculate_joint_hash():
     ```python
     class JointAnalysisService:
         """Service for dual-filer MFJ vs MFS analysis"""

         @staticmethod
         def _calculate_joint_hash(spouse1_id, spouse2_id):
             """
             Calculate combined hash from both spouses' individual hashes.
             If either spouse's data changes, joint hash changes.

             Returns:
                 str: SHA-256 hash combining both spouse hashes
             """
             # Get individual hashes (includes spouse data due to REQ-08)
             spouse1_hash = AnalysisEngine._calculate_data_version_hash(spouse1_id)
             spouse2_hash = AnalysisEngine._calculate_data_version_hash(spouse2_id)

             # Combine in consistent order (lower ID first for symmetry)
             ordered_ids = sorted([spouse1_id, spouse2_id])
             combined_string = f"{spouse1_hash}|{spouse2_hash}|{ordered_ids[0]}|{ordered_ids[1]}"

             return hashlib.sha256(combined_string.encode('utf-8')).hexdigest()
     ```

  3. Create analyze_joint() method signature:
     ```python
     @staticmethod
     def analyze_joint(spouse1_id, spouse2_id, force_refresh=False):
         """
         Orchestrate joint analysis: MFJ scenario, MFS scenario, comparison.

         Args:
             spouse1_id: First spouse client ID
             spouse2_id: Second spouse client ID
             force_refresh: Skip cache and recalculate

         Returns:
             dict: {
                 'spouse1': {'summary': ..., 'strategies': ...},
                 'spouse2': {'summary': ..., 'strategies': ...},
                 'mfj': {...},
                 'mfs_spouse1': {...},
                 'mfs_spouse2': {...},
                 'comparison': {'recommended_status': ..., 'savings': ..., ...}
             }
         """
     ```

  4. Implement analyze_joint() cache check:
     ```python
     # Step 1: Validate spouses are linked
     spouse1 = Client.query.get(spouse1_id)
     spouse2 = Client.query.get(spouse2_id)

     if not spouse1 or not spouse2:
         raise ValueError("Both spouse IDs must be valid")

     if spouse1.spouse_id != spouse2_id or spouse2.spouse_id != spouse1_id:
         raise ValueError("Clients must be linked as spouses")

     # Step 2: Calculate combined hash
     joint_hash = JointAnalysisService._calculate_joint_hash(spouse1_id, spouse2_id)

     # Step 3: Check cache
     cached = JointAnalysisSummary.query.filter_by(
         spouse1_id=spouse1_id,
         spouse2_id=spouse2_id
     ).first()

     if cached and cached.data_version_hash == joint_hash and not force_refresh:
         # Return cached result (will implement in Task 3)
         return JointAnalysisService._format_cached_result(cached, spouse1_id, spouse2_id)
     ```

  5. Implement MFJ calculation (REQ-01, REQ-07):
     ```python
     # Step 4: Analyze each spouse individually
     spouse1_strategies, spouse1_summary = AnalysisEngine.analyze_client(spouse1_id)
     spouse2_strategies, spouse2_summary = AnalysisEngine.analyze_client(spouse2_id)

     # Step 5: Calculate MFJ scenario
     tax_year = spouse1_summary.get('tax_year', 2026)
     combined_income = spouse1_summary['total_income'] + spouse2_summary['total_income']

     # REQ-07: MFJ standard deduction ($32,200 for 2026)
     mfj_std_deduction = TaxCalculator.get_standard_deduction(
         filing_status='married_joint',
         tax_type='federal',
         tax_year=tax_year
     )

     # Calculate MFJ taxable income
     mfj_taxable = TaxCalculator.calculate_taxable_income(
         gross_income=combined_income,
         standard_deduction=mfj_std_deduction,
         qbi_deduction=0  # Phase 1: simplified, no QBI yet
     )

     # Get MFJ brackets and calculate tax
     mfj_brackets = TaxCalculator.get_tax_brackets(
         tax_type='federal',
         filing_status='married_joint',
         tax_year=tax_year
     )

     mfj_tax_result = TaxCalculator.calculate_tax_by_brackets(
         taxable_income=mfj_taxable,
         brackets=mfj_brackets
     )

     # Build MFJ result dict
     mfj_result = {
         'combined_income': combined_income,
         'agi': combined_income,  # Simplified for Phase 1
         'standard_deduction': mfj_std_deduction,
         'taxable_income': mfj_taxable,
         'total_tax': mfj_tax_result['total_tax'],
         'marginal_rate': mfj_tax_result['marginal_rate'],
         'effective_rate': (mfj_tax_result['total_tax'] / combined_income * 100) if combined_income > 0 else 0
     }
     ```

  DO reuse TaxCalculator methods (get_standard_deduction, calculate_taxable_income, get_tax_brackets, calculate_tax_by_brackets).
  DO NOT rewrite bracket logic or deduction lookup.
  DO use Decimal for intermediate calculations if dealing with currency math (convert to float only for storage).

  Why orchestration: TaxCalculator already handles married_joint filing status correctly (verified in research lines 96-108). Service coordinates calls but doesn't duplicate logic.
  </action>
  <verify>
  Run test:
  ```python
  from app import app
  from services.joint_analysis_service import JointAnalysisService
  from models import Client, ExtractedData, db

  app.app_context().push()

  # Create linked spouses with income data
  # (assumes test data exists or create minimal test)

  result = JointAnalysisService.analyze_joint(spouse1_id=1, spouse2_id=2, force_refresh=True)

  print("Has MFJ result:", 'mfj' in result)
  print("MFJ total tax:", result['mfj']['total_tax'])
  print("MFJ standard deduction:", result['mfj']['standard_deduction'])
  ```
  Expected: Has MFJ result: True, MFJ standard deduction: 32200.0
  </verify>
  <done>
  - JointAnalysisService class created
  - _calculate_joint_hash() combines both spouse hashes
  - analyze_joint() validates spouse linkage
  - analyze_joint() checks cache with combined hash
  - MFJ calculation uses married_joint brackets
  - MFJ uses $32,200 standard deduction (REQ-07)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add MFS Calculation and Comparison Logic</name>
  <files>services/joint_analysis_service.py</files>
  <action>
  Extend analyze_joint() with MFS calculation and comparison generation (REQ-02, REQ-03, REQ-07).

  1. Add MFS calculation after MFJ calculation (continuing in analyze_joint()):
     ```python
     # Step 6: Calculate MFS scenario for both spouses
     # REQ-07: MFS standard deduction ($16,100 per spouse for 2026)
     mfs_std_deduction = TaxCalculator.get_standard_deduction(
         filing_status='married_separate',
         tax_type='federal',
         tax_year=tax_year
     )

     # Calculate spouse1 MFS
     mfs_spouse1_taxable = TaxCalculator.calculate_taxable_income(
         gross_income=spouse1_summary['total_income'],
         standard_deduction=mfs_std_deduction,
         qbi_deduction=0  # Phase 1: simplified
     )

     mfs_brackets = TaxCalculator.get_tax_brackets(
         tax_type='federal',
         filing_status='married_separate',
         tax_year=tax_year
     )

     mfs_spouse1_tax_result = TaxCalculator.calculate_tax_by_brackets(
         taxable_income=mfs_spouse1_taxable,
         brackets=mfs_brackets
     )

     # Calculate spouse2 MFS (same brackets, different income)
     mfs_spouse2_taxable = TaxCalculator.calculate_taxable_income(
         gross_income=spouse2_summary['total_income'],
         standard_deduction=mfs_std_deduction,
         qbi_deduction=0
     )

     mfs_spouse2_tax_result = TaxCalculator.calculate_tax_by_brackets(
         taxable_income=mfs_spouse2_taxable,
         brackets=mfs_brackets
     )

     # Build MFS result dicts
     mfs_spouse1_result = {
         'income': spouse1_summary['total_income'],
         'agi': spouse1_summary['total_income'],  # Simplified
         'standard_deduction': mfs_std_deduction,
         'taxable_income': mfs_spouse1_taxable,
         'total_tax': mfs_spouse1_tax_result['total_tax'],
         'marginal_rate': mfs_spouse1_tax_result['marginal_rate'],
         'effective_rate': (mfs_spouse1_tax_result['total_tax'] / spouse1_summary['total_income'] * 100) if spouse1_summary['total_income'] > 0 else 0
     }

     mfs_spouse2_result = {
         'income': spouse2_summary['total_income'],
         'agi': spouse2_summary['total_income'],
         'standard_deduction': mfs_std_deduction,
         'taxable_income': mfs_spouse2_taxable,
         'total_tax': mfs_spouse2_tax_result['total_tax'],
         'marginal_rate': mfs_spouse2_tax_result['marginal_rate'],
         'effective_rate': (mfs_spouse2_tax_result['total_tax'] / spouse2_summary['total_income'] * 100) if spouse2_summary['total_income'] > 0 else 0
     }

     mfs_combined_tax = mfs_spouse1_result['total_tax'] + mfs_spouse2_result['total_tax']
     ```

  2. Add comparison logic (REQ-03):
     ```python
     # Step 7: Generate comparison and recommendation
     savings = mfs_combined_tax - mfj_result['total_tax']
     recommended_status = 'MFJ' if savings > 0 else 'MFS'

     comparison = {
         'recommended_status': recommended_status,
         'savings_amount': abs(savings),
         'mfj_total_tax': mfj_result['total_tax'],
         'mfs_total_tax': mfs_combined_tax,
         'reason': f"{'MFJ' if savings > 0 else 'MFS'} saves ${abs(savings):,.2f}"
     }
     ```

  3. Add cache storage:
     ```python
     # Step 8: Store result in cache
     if cached:
         # Update existing
         cached.tax_year = tax_year
         cached.mfj_combined_income = mfj_result['combined_income']
         cached.mfj_agi = mfj_result['agi']
         cached.mfj_taxable_income = mfj_result['taxable_income']
         cached.mfj_total_tax = mfj_result['total_tax']
         cached.mfj_effective_rate = mfj_result['effective_rate']
         cached.mfj_standard_deduction = mfj_result['standard_deduction']
         cached.mfs_spouse1_income = mfs_spouse1_result['income']
         cached.mfs_spouse1_agi = mfs_spouse1_result['agi']
         cached.mfs_spouse1_taxable_income = mfs_spouse1_result['taxable_income']
         cached.mfs_spouse1_tax = mfs_spouse1_result['total_tax']
         cached.mfs_spouse2_income = mfs_spouse2_result['income']
         cached.mfs_spouse2_agi = mfs_spouse2_result['agi']
         cached.mfs_spouse2_taxable_income = mfs_spouse2_result['taxable_income']
         cached.mfs_spouse2_tax = mfs_spouse2_result['total_tax']
         cached.mfs_combined_tax = mfs_combined_tax
         cached.mfs_effective_rate = (mfs_combined_tax / combined_income * 100) if combined_income > 0 else 0
         cached.mfs_standard_deduction = mfs_std_deduction
         cached.recommended_status = recommended_status
         cached.savings_amount = abs(savings)
         cached.data_version_hash = joint_hash
         cached.last_analyzed_at = datetime.utcnow()
     else:
         # Create new
         cached = JointAnalysisSummary(
             spouse1_id=spouse1_id,
             spouse2_id=spouse2_id,
             tax_year=tax_year,
             mfj_combined_income=mfj_result['combined_income'],
             mfj_agi=mfj_result['agi'],
             mfj_taxable_income=mfj_result['taxable_income'],
             mfj_total_tax=mfj_result['total_tax'],
             mfj_effective_rate=mfj_result['effective_rate'],
             mfj_standard_deduction=mfj_result['standard_deduction'],
             mfs_spouse1_income=mfs_spouse1_result['income'],
             mfs_spouse1_agi=mfs_spouse1_result['agi'],
             mfs_spouse1_taxable_income=mfs_spouse1_result['taxable_income'],
             mfs_spouse1_tax=mfs_spouse1_result['total_tax'],
             mfs_spouse2_income=mfs_spouse2_result['income'],
             mfs_spouse2_agi=mfs_spouse2_result['agi'],
             mfs_spouse2_taxable_income=mfs_spouse2_result['taxable_income'],
             mfs_spouse2_tax=mfs_spouse2_result['total_tax'],
             mfs_combined_tax=mfs_combined_tax,
             mfs_effective_rate=(mfs_combined_tax / combined_income * 100) if combined_income > 0 else 0,
             mfs_standard_deduction=mfs_std_deduction,
             recommended_status=recommended_status,
             savings_amount=abs(savings),
             data_version_hash=joint_hash
         )
         db.session.add(cached)

     db.session.commit()
     ```

  4. Add return statement:
     ```python
     # Step 9: Return structured result
     return {
         'spouse1': {
             'summary': spouse1_summary,
             'strategies': [s.to_dict() for s in spouse1_strategies]
         },
         'spouse2': {
             'summary': spouse2_summary,
             'strategies': [s.to_dict() for s in spouse2_strategies]
         },
         'mfj': mfj_result,
         'mfs_spouse1': mfs_spouse1_result,
         'mfs_spouse2': mfs_spouse2_result,
         'comparison': comparison
     }
     ```

  5. Add _format_cached_result() helper (referenced in Task 2):
     ```python
     @staticmethod
     def _format_cached_result(cached, spouse1_id, spouse2_id):
         """Format cached JointAnalysisSummary into return structure"""
         # Get individual analyses (these are cached too)
         spouse1_strategies, spouse1_summary = AnalysisEngine.analyze_client(spouse1_id)
         spouse2_strategies, spouse2_summary = AnalysisEngine.analyze_client(spouse2_id)

         return {
             'spouse1': {
                 'summary': spouse1_summary,
                 'strategies': [s.to_dict() for s in spouse1_strategies]
             },
             'spouse2': {
                 'summary': spouse2_summary,
                 'strategies': [s.to_dict() for s in spouse2_strategies]
             },
             'mfj': {
                 'combined_income': cached.mfj_combined_income,
                 'agi': cached.mfj_agi,
                 'standard_deduction': cached.mfj_standard_deduction,
                 'taxable_income': cached.mfj_taxable_income,
                 'total_tax': cached.mfj_total_tax,
                 'marginal_rate': 0,  # Not stored in cache yet
                 'effective_rate': cached.mfj_effective_rate
             },
             'mfs_spouse1': {
                 'income': cached.mfs_spouse1_income,
                 'agi': cached.mfs_spouse1_agi,
                 'standard_deduction': cached.mfs_standard_deduction,
                 'taxable_income': cached.mfs_spouse1_taxable_income,
                 'total_tax': cached.mfs_spouse1_tax,
                 'marginal_rate': 0,
                 'effective_rate': (cached.mfs_spouse1_tax / cached.mfs_spouse1_income * 100) if cached.mfs_spouse1_income > 0 else 0
             },
             'mfs_spouse2': {
                 'income': cached.mfs_spouse2_income,
                 'agi': cached.mfs_spouse2_agi,
                 'standard_deduction': cached.mfs_standard_deduction,
                 'taxable_income': cached.mfs_spouse2_taxable_income,
                 'total_tax': cached.mfs_spouse2_tax,
                 'marginal_rate': 0,
                 'effective_rate': (cached.mfs_spouse2_tax / cached.mfs_spouse2_income * 100) if cached.mfs_spouse2_income > 0 else 0
             },
             'comparison': {
                 'recommended_status': cached.recommended_status,
                 'savings_amount': cached.savings_amount,
                 'mfj_total_tax': cached.mfj_total_tax,
                 'mfs_total_tax': cached.mfs_combined_tax,
                 'reason': f"{cached.recommended_status} saves ${cached.savings_amount:,.2f}"
             }
         }
     ```

  DO use same mfs_brackets for both spouses (filing_status='married_separate' brackets are identical per spouse).
  DO calculate MFS combined tax as sum of both spouses' individual taxes.
  DO NOT mix MFJ and MFS deductions (MFJ=$32,200, MFS=$16,100 each).

  Why separate MFS calculations: Each spouse files independently with own income, own standard deduction, own brackets. Combined tax is simple sum.
  </action>
  <verify>
  Run test:
  ```python
  result = JointAnalysisService.analyze_joint(spouse1_id=1, spouse2_id=2, force_refresh=True)

  print("Has MFS spouse1:", 'mfs_spouse1' in result)
  print("Has comparison:", 'comparison' in result)
  print("MFS std deduction:", result['mfs_spouse1']['standard_deduction'])
  print("Recommended status:", result['comparison']['recommended_status'])
  print("Savings amount:", result['comparison']['savings_amount'])
  ```
  Expected: Has MFS spouse1: True, MFS std deduction: 16100.0, recommended_status in ['MFJ', 'MFS']
  </verify>
  <done>
  - analyze_joint() calculates MFS for both spouses
  - MFS uses married_separate brackets
  - MFS uses $16,100 standard deduction per spouse (REQ-07)
  - Comparison shows recommended status and dollar savings
  - Result cached in JointAnalysisSummary table
  - _format_cached_result() handles cache retrieval
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Test bidirectional cache invalidation:
   ```python
   # Create two linked spouses with data
   # Run joint analysis
   # Change spouse2's data
   # Verify spouse1's individual analysis hash changed
   # Verify joint analysis hash changed
   ```

2. Test MFJ vs MFS calculation:
   ```python
   # Spouse1: $250,000 income
   # Spouse2: $100,000 income
   # Combined: $350,000

   result = JointAnalysisService.analyze_joint(spouse1_id, spouse2_id, force_refresh=True)

   # Verify MFJ uses $32,200 standard deduction
   # Verify MFS uses $16,100 per spouse
   # Verify MFS combined tax = spouse1_tax + spouse2_tax
   # Verify comparison shows which status saves more
   ```

3. Test cache behavior:
   ```python
   # First call: force_refresh=True (calculates fresh)
   # Second call: force_refresh=False (returns cached)
   # Verify second call faster and returns same results
   ```
</verification>

<success_criteria>
1. JointAnalysisService.analyze_joint() accepts two spouse IDs and returns structured comparison
2. MFJ calculation uses married_joint brackets with $32,200 standard deduction (REQ-01, REQ-07)
3. MFS calculation uses married_separate brackets with $16,100 per spouse standard deduction (REQ-02, REQ-07)
4. Comparison shows recommended filing status and dollar savings amount (REQ-03)
5. Changing either spouse's data invalidates both individual and joint cached analyses (REQ-08)
6. Result cached in joint_analysis_summaries table with combined hash
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-calculation-engine/01-02-SUMMARY.md`
</output>
