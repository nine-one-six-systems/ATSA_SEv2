---
phase: 01-core-calculation-engine
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - services/joint_analysis_service.py
autonomous: true

must_haves:
  truths:
    - "MFS calculations exclude EITC, student loan interest, and education credits"
    - "MFS QBI deduction uses $197,300 threshold, not $383,900 MFJ threshold"
    - "MFJ calculations include all eligible credits"
  artifacts:
    - path: "services/joint_analysis_service.py"
      provides: "Credit eligibility filtering and QBI threshold enforcement"
      contains: "CREDIT_ELIGIBILITY"
  key_links:
    - from: "services/joint_analysis_service.py"
      to: "services.tax_calculator.TaxCalculator"
      via: "QBI threshold lookup by filing status"
      pattern: "get_qbi_income_thresholds.*married_separate"
---

<objective>
Enforce filing-status-specific credit eligibility and QBI income thresholds to ensure MFS calculations accurately reflect IRS restrictions, preventing phantom tax savings from unavailable credits.

Purpose: Critical pitfalls #3 and #4 from research. MFS filers are INELIGIBLE (not phased out) for EITC, student loan interest deduction, and education credits. MFS QBI threshold is $197,300 (same as single), not $383,900 (MFJ). Without enforcement, real use case ($250k LLC + $100k W-2) shows incorrect MFS results.

Output: Credit eligibility matrix filtering strategies by filing status, QBI threshold verification for MFS, comparison notes explaining credit/deduction differences.
</objective>

<execution_context>
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/workflows/execute-plan.md
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/samueledwards/ATSA_SEv2/.planning/PROJECT.md
@/Users/samueledwards/ATSA_SEv2/.planning/ROADMAP.md
@/Users/samueledwards/ATSA_SEv2/.planning/REQUIREMENTS.md
@/Users/samueledwards/ATSA_SEv2/.planning/LEARNINGS.md
@/Users/samueledwards/ATSA_SEv2/.planning/phases/01-core-calculation-engine/01-RESEARCH.md

# Research sections on pitfalls
# Lines 446-516: Credit disqualification pitfall
# Lines 518-566: QBI threshold confusion pitfall

@/Users/samueledwards/ATSA_SEv2/services/joint_analysis_service.py
@/Users/samueledwards/ATSA_SEv2/services/tax_calculator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Credit Eligibility Matrix</name>
  <files>services/joint_analysis_service.py</files>
  <action>
  Add filing-status-aware credit eligibility filtering to prevent MFS from showing ineligible credits (REQ-05).

  1. Add constant at top of JointAnalysisService class (after class definition):
     ```python
     # REQ-05: Credit eligibility by filing status
     # MFS filers are INELIGIBLE (not phased out) for these credits
     CREDIT_ELIGIBILITY = {
         'EITC': {
             'single': True,
             'married_joint': True,
             'married_separate': False,  # Completely ineligible
             'head_of_household': True
         },
         'student_loan_interest': {
             'single': True,
             'married_joint': True,
             'married_separate': False,  # $0 deduction, not phased out
             'head_of_household': True
         },
         'education_credits': {  # AOTC, LLC
             'single': True,
             'married_joint': True,
             'married_separate': False,  # Ineligible
             'head_of_household': True
         },
         'adoption_credit': {
             'single': True,
             'married_joint': True,
             'married_separate': False,  # Ineligible
             'head_of_household': True
         }
     }
     ```

  2. Add helper method _identify_credit_type():
     ```python
     @staticmethod
     def _identify_credit_type(strategy_name):
         """
         Map strategy name to credit eligibility key.

         Returns:
             str: Credit type key or None if not a restricted credit
         """
         name_lower = strategy_name.lower()

         if 'eitc' in name_lower or 'earned income' in name_lower:
             return 'EITC'
         elif 'student loan' in name_lower:
             return 'student_loan_interest'
         elif 'education credit' in name_lower or 'american opportunity' in name_lower or 'lifetime learning' in name_lower:
             return 'education_credits'
         elif 'adoption' in name_lower:
             return 'adoption_credit'
         else:
             return None  # Not a restricted credit
     ```

  3. Add _filter_strategies_by_filing_status() method:
     ```python
     @staticmethod
     def _filter_strategies_by_filing_status(strategies, filing_status):
         """
         Remove strategies ineligible for filing status.

         Args:
             strategies: List of AnalysisResult objects
             filing_status: Filing status string

         Returns:
             tuple: (filtered_strategies, removed_credit_names)
         """
         filtered = []
         removed = []

         for strategy in strategies:
             credit_type = JointAnalysisService._identify_credit_type(strategy.strategy_name)

             if credit_type and credit_type in JointAnalysisService.CREDIT_ELIGIBILITY:
                 # This is a restricted credit, check eligibility
                 eligible = JointAnalysisService.CREDIT_ELIGIBILITY[credit_type].get(filing_status, False)
                 if eligible:
                     filtered.append(strategy)
                 else:
                     removed.append(strategy.strategy_name)
             else:
                 # Not a restricted credit, always include
                 filtered.append(strategy)

         return filtered, removed
     ```

  4. Integrate into analyze_joint() after individual analyses (after Step 4 in Plan 02):
     ```python
     # Filter strategies for MFS (remove ineligible credits)
     mfs_spouse1_strategies, removed_spouse1 = JointAnalysisService._filter_strategies_by_filing_status(
         spouse1_strategies, 'married_separate'
     )
     mfs_spouse2_strategies, removed_spouse2 = JointAnalysisService._filter_strategies_by_filing_status(
         spouse2_strategies, 'married_separate'
     )

     # Track removed credits for comparison notes
     removed_credits = list(set(removed_spouse1 + removed_spouse2))
     ```

  5. Add comparison note if credits lost:
     ```python
     # In comparison dict (Step 7), add:
     comparison_notes = []
     if removed_credits:
         comparison_notes.append({
             'type': 'credit_restriction',
             'message': f"MFS ineligible for: {', '.join(removed_credits)}",
             'impact': 'MFS tax may be higher due to unavailable credits'
         })

     comparison['notes'] = comparison_notes
     ```

  DO use exact credit type keys matching CREDIT_ELIGIBILITY dict.
  DO return both filtered strategies AND list of removed credit names.
  DO NOT modify TaxStrategiesService (that's a separate service, we filter its output here).

  Why filtering not modifying: TaxStrategiesService generates all possible strategies for any client. JointAnalysisService applies filing-status filtering as a layer on top. Clean separation of concerns.

  Why tracking removed credits: Comparison view (Phase 3 UI) needs to explain why MFS shows fewer strategies than MFJ.
  </action>
  <verify>
  Run test:
  ```python
  from services.joint_analysis_service import JointAnalysisService
  from models import AnalysisResult

  # Create mock strategies including restricted credits
  strategies = [
      AnalysisResult(strategy_name="EITC Credit", strategy_description="...", irs_section="IRC 32"),
      AnalysisResult(strategy_name="Student Loan Interest Deduction", strategy_description="...", irs_section="IRC 221"),
      AnalysisResult(strategy_name="SEP-IRA Contribution", strategy_description="...", irs_section="IRC 408")
  ]

  filtered_mfs, removed = JointAnalysisService._filter_strategies_by_filing_status(strategies, 'married_separate')
  filtered_mfj, _ = JointAnalysisService._filter_strategies_by_filing_status(strategies, 'married_joint')

  print("MFS strategies:", len(filtered_mfs))  # Should be 1 (SEP-IRA only)
  print("MFJ strategies:", len(filtered_mfj))  # Should be 3 (all)
  print("Removed credits:", removed)  # Should be ['EITC Credit', 'Student Loan Interest Deduction']
  ```
  Expected: MFS strategies: 1, MFJ strategies: 3
  </verify>
  <done>
  - CREDIT_ELIGIBILITY dict defines filing status rules for 4 credit types
  - _identify_credit_type() maps strategy names to credit types
  - _filter_strategies_by_filing_status() removes ineligible credits
  - analyze_joint() filters MFS strategies before comparison
  - Comparison notes list removed credits with explanation
  </done>
</task>

<task type="auto">
  <name>Task 2: Enforce QBI Threshold by Filing Status</name>
  <files>services/joint_analysis_service.py</files>
  <action>
  Verify TaxCalculator uses correct QBI thresholds and add comparison note when MFS threshold affects deduction (REQ-06).

  1. Add _check_qbi_impact() helper method:
     ```python
     @staticmethod
     def _check_qbi_impact(income, filing_status, tax_year=2026):
         """
         Check if income exceeds QBI threshold for filing status.

         REQ-06: MFS uses $197,300 threshold (same as single), not $383,900 (MFJ).
         Research verified: TaxCalculator already implements correct thresholds
         (tax_calculator.py lines 304-312).

         Args:
             income: Gross income amount
             filing_status: Filing status string
             tax_year: Tax year

         Returns:
             dict: {'exceeds_threshold': bool, 'threshold': float, 'note': str}
         """
         # Get QBI thresholds from TaxCalculator
         # Note: This method exists in TaxCalculator (verified in research)
         try:
             thresholds = TaxCalculator.get_qbi_income_thresholds(
                 filing_status=filing_status,
                 tax_year=tax_year
             )
             threshold = thresholds.get('phase_out_start', 0)
         except AttributeError:
             # Fallback if method doesn't exist (use known 2026 values)
             threshold_map = {
                 'single': 197300,
                 'married_joint': 394600,
                 'married_separate': 197300,  # REQ-06: Same as single
                 'head_of_household': 197300
             }
             threshold = threshold_map.get(filing_status, 197300)

         exceeds = income > threshold

         note = None
         if exceeds:
             note = f"Income ${income:,.0f} exceeds QBI threshold (${threshold:,.0f}) — QBI deduction may be limited or phased out"

         return {
             'exceeds_threshold': exceeds,
             'threshold': threshold,
             'note': note
         }
     ```

  2. Integrate QBI check into analyze_joint() (after MFS calculation in Plan 02 Step 6):
     ```python
     # Check QBI impact for each spouse on MFS
     qbi_spouse1 = JointAnalysisService._check_qbi_impact(
         income=spouse1_summary['total_income'],
         filing_status='married_separate',
         tax_year=tax_year
     )

     qbi_spouse2 = JointAnalysisService._check_qbi_impact(
         income=spouse2_summary['total_income'],
         filing_status='married_separate',
         tax_year=tax_year
     )

     qbi_mfj = JointAnalysisService._check_qbi_impact(
         income=combined_income,
         filing_status='married_joint',
         tax_year=tax_year
     )
     ```

  3. Add QBI notes to comparison (in Step 7 comparison_notes):
     ```python
     # Add QBI threshold notes
     if qbi_spouse1['exceeds_threshold'] and not qbi_mfj['exceeds_threshold']:
         comparison_notes.append({
             'type': 'qbi_threshold',
             'message': f"Spouse 1 exceeds MFS QBI threshold (${qbi_spouse1['threshold']:,.0f}), but combined income under MFJ threshold (${qbi_mfj['threshold']:,.0f})",
             'impact': 'MFJ may preserve full QBI deduction'
         })

     if qbi_spouse2['exceeds_threshold'] and not qbi_mfj['exceeds_threshold']:
         comparison_notes.append({
             'type': 'qbi_threshold',
             'message': f"Spouse 2 exceeds MFS QBI threshold (${qbi_spouse2['threshold']:,.0f}), but combined income under MFJ threshold (${qbi_mfj['threshold']:,.0f})",
             'impact': 'MFJ may preserve full QBI deduction'
         })
     ```

  4. Add verification comment in analyze_joint():
     ```python
     # NOTE: TaxCalculator.get_qbi_income_thresholds() already uses correct thresholds:
     # - married_separate: $197,300 (verified in tax_calculator.py line 309)
     # - married_joint: $394,600
     # No modification to TaxCalculator needed. We only add comparison notes here.
     ```

  DO use TaxCalculator.get_qbi_income_thresholds() if it exists.
  DO provide fallback threshold map if method doesn't exist (defensive coding).
  DO NOT modify TaxCalculator (research verified it's already correct).

  Why verification: Research lines 304-312 show TaxCalculator already has correct thresholds. This task adds comparison notes explaining impact, not fixing broken logic.

  Why this matters: Real use case has husband with $250k LLC income. On MFS, this exceeds $197,300 threshold → QBI deduction limited. On MFJ, combined $350k is under $394,600 → full QBI deduction. This difference drives the recommendation.
  </action>
  <verify>
  Run test:
  ```python
  from services.joint_analysis_service import JointAnalysisService

  # Test QBI threshold detection
  result_mfs = JointAnalysisService._check_qbi_impact(250000, 'married_separate', 2026)
  result_mfj = JointAnalysisService._check_qbi_impact(350000, 'married_joint', 2026)

  print("MFS $250k exceeds threshold:", result_mfs['exceeds_threshold'])  # True
  print("MFS threshold:", result_mfs['threshold'])  # 197300
  print("MFJ $350k exceeds threshold:", result_mfj['exceeds_threshold'])  # False
  print("MFJ threshold:", result_mfj['threshold'])  # 394600
  ```
  Expected: MFS $250k exceeds: True, MFJ $350k exceeds: False
  </verify>
  <done>
  - _check_qbi_impact() detects when income exceeds threshold
  - QBI threshold lookup uses correct values per filing status (REQ-06)
  - MFS threshold is $197,300 (same as single)
  - MFJ threshold is $394,600 (not double of MFS)
  - Comparison notes explain QBI threshold impact
  - Comment documents that TaxCalculator already correct
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Filing Status Validation and Documentation</name>
  <files>services/joint_analysis_service.py</files>
  <action>
  Add comprehensive docstrings and validation ensuring filing status strings match expected values.

  1. Add module-level docstring at top of file:
     ```python
     """
     Joint Analysis Service - Dual-Filer MFJ vs MFS Comparison

     This service orchestrates dual-filer tax analysis by coordinating existing
     AnalysisEngine and TaxCalculator components. It does NOT rewrite tax calculation
     logic -- it calls existing methods with correct filing statuses.

     Key Features:
     - REQ-01: MFJ calculation using married_joint brackets and $32,200 standard deduction
     - REQ-02: MFS calculation using married_separate brackets and $16,100 per spouse
     - REQ-03: Three-column comparison (MFJ, MFS spouse1, MFS spouse2) with recommendation
     - REQ-05: Credit eligibility filtering (MFS ineligible for EITC, student loan, education)
     - REQ-06: QBI threshold enforcement (MFS $197,300, MFJ $394,600)
     - REQ-08: Bidirectional cache invalidation via combined hash

     Filing Status Values:
     - 'married_joint' for MFJ calculations
     - 'married_separate' for MFS calculations
     - These exact strings must match TaxBracket.filing_status database values

     Anti-Patterns Avoided:
     - Do NOT modify TaxCalculator (it already handles all filing statuses correctly)
     - Do NOT use 'married' as filing status (ambiguous, must specify joint or separate)
     - Do NOT calculate MFJ as sum of two MFS (different brackets, different deductions)
     - Do NOT allow mismatched deduction methods (Phase 2 enforcement)
     """
     ```

  2. Add validation in analyze_joint() before calculations:
     ```python
     # Validate filing statuses are compatible
     if spouse1.filing_status not in ['married_joint', 'married_separate']:
         raise ValueError(f"Spouse 1 filing status must be married_joint or married_separate, got: {spouse1.filing_status}")

     if spouse2.filing_status not in ['married_joint', 'married_separate']:
         raise ValueError(f"Spouse 2 filing status must be married_joint or married_separate, got: {spouse2.filing_status}")
     ```

  3. Add constant documenting 2026 values:
     ```python
     # 2026 Tax Year Constants (for reference and testing)
     STANDARD_DEDUCTIONS_2026 = {
         'married_joint': 32200,
         'married_separate': 16100,
         'single': 16100,
         'head_of_household': 23650
     }

     QBI_THRESHOLDS_2026 = {
         'married_joint': 394600,
         'married_separate': 197300,
         'single': 197300,
         'head_of_household': 197300
     }
     ```

  4. Add to_dict() method to JointAnalysisService for testing:
     ```python
     @staticmethod
     def get_comparison_summary(spouse1_id, spouse2_id):
         """
         Get concise comparison summary (for testing/debugging).

         Returns:
             dict: {
                 'mfj_tax': float,
                 'mfs_tax': float,
                 'recommended': str,
                 'savings': float
             }
         """
         result = JointAnalysisService.analyze_joint(spouse1_id, spouse2_id)
         return {
             'mfj_tax': result['mfj']['total_tax'],
             'mfs_tax': result['comparison']['mfs_total_tax'],
             'recommended': result['comparison']['recommended_status'],
             'savings': result['comparison']['savings_amount']
         }
     ```

  DO add detailed docstrings explaining what the service does and doesn't do.
  DO document known values for 2026 (helps with testing and verification).
  DO validate filing status strings before calculations.

  Why documentation: Future developers (or Claude in later phases) need to understand that this service coordinates existing components, not reimplements tax logic. Prevents accidental duplication.
  </action>
  <verify>
  Run test:
  ```python
  from services.joint_analysis_service import JointAnalysisService

  # Verify constants accessible
  print("MFJ std deduction:", JointAnalysisService.STANDARD_DEDUCTIONS_2026['married_joint'])
  print("MFS QBI threshold:", JointAnalysisService.QBI_THRESHOLDS_2026['married_separate'])

  # Verify validation catches bad filing status
  try:
      # Assumes test client with filing_status='single'
      result = JointAnalysisService.analyze_joint(single_client_id, spouse_id)
  except ValueError as e:
      print("Validation caught:", str(e))
  ```
  Expected: Constants print correctly, validation raises ValueError
  </verify>
  <done>
  - Module docstring explains service purpose and anti-patterns
  - Filing status validation ensures married_joint or married_separate
  - 2026 constants documented for reference
  - get_comparison_summary() helper for concise testing
  - Docstrings explain REQ-01, REQ-02, REQ-05, REQ-06 enforcement
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Test credit eligibility filtering:
   ```python
   # Create test client with EITC and student loan strategies
   # Run joint analysis
   # Verify MFJ result includes all strategies
   # Verify MFS result excludes EITC and student loan
   # Verify comparison notes list removed credits
   ```

2. Test QBI threshold detection:
   ```python
   # Spouse1: $250,000 LLC income
   # Spouse2: $100,000 W-2 income
   # Run joint analysis
   # Verify comparison notes mention QBI threshold for spouse1 on MFS
   # Verify notes explain MFJ preserves QBI deduction
   ```

3. Test filing status validation:
   ```python
   # Create client with filing_status='single'
   # Attempt joint analysis
   # Verify ValueError raised
   ```

4. Integration test:
   ```python
   result = JointAnalysisService.analyze_joint(spouse1_id, spouse2_id, force_refresh=True)

   # Verify MFS strategies fewer than MFJ strategies (due to credit filtering)
   # Verify comparison notes exist and explain differences
   # Verify QBI impact noted if applicable
   ```
</verification>

<success_criteria>
1. MFS strategies exclude EITC, student loan interest, and education credits (REQ-05)
2. Credit filtering tracked in comparison notes with explanation
3. QBI threshold check uses $197,300 for MFS, $394,600 for MFJ (REQ-06)
4. Comparison notes explain QBI impact when income exceeds thresholds
5. Filing status validation prevents invalid inputs
6. Module documentation explains service purpose and anti-patterns
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-calculation-engine/01-03-SUMMARY.md`
</output>
