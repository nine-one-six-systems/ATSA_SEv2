---
phase: 01-core-calculation-engine
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - routes/joint_analysis.py
  - routes/api.py
autonomous: true

must_haves:
  truths:
    - "GET /api/analysis/joint/<spouse1_id>/<spouse2_id> returns MFJ + MFS comparison"
    - "POST /api/analysis/joint/<spouse1_id>/<spouse2_id>/refresh forces recalculation"
    - "API validates spouse linkage before analysis"
    - "Response includes three-column comparison with recommendation"
  artifacts:
    - path: "routes/joint_analysis.py"
      provides: "Blueprint with joint analysis endpoints"
      min_lines: 80
      exports: ["joint_analysis_bp"]
    - path: "routes/api.py"
      provides: "Blueprint registration"
      contains: "joint_analysis_bp"
  key_links:
    - from: "routes/joint_analysis.py"
      to: "services.joint_analysis_service.JointAnalysisService"
      via: "analyze_joint() delegation"
      pattern: "JointAnalysisService\\.analyze_joint"
    - from: "routes/api.py"
      to: "routes.joint_analysis"
      via: "blueprint registration"
      pattern: "register_blueprint.*joint_analysis"
---

<objective>
Expose joint analysis functionality via RESTful API endpoints, enabling frontend to trigger dual-filer analysis, retrieve cached results, and force refresh when needed.

Purpose: Final piece of Phase 1 backend. Routes are thin wrappers delegating to JointAnalysisService, following existing pattern from routes/analysis.py. API provides data access for Phase 3 split-screen UI.

Output: Working API endpoints returning structured JSON with MFJ totals, MFS totals per spouse, comparison with recommendation, and individual spouse summaries with strategies.
</objective>

<execution_context>
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/workflows/execute-plan.md
@/Users/samueledwards/ATSA_SEv2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/samueledwards/ATSA_SEv2/.planning/PROJECT.md
@/Users/samueledwards/ATSA_SEv2/.planning/ROADMAP.md
@/Users/samueledwards/ATSA_SEv2/.planning/REQUIREMENTS.md
@/Users/samueledwards/ATSA_SEv2/.planning/LEARNINGS.md
@/Users/samueledwards/ATSA_SEv2/.planning/phases/01-core-calculation-engine/01-RESEARCH.md

# Route patterns
@/Users/samueledwards/ATSA_SEv2/routes/analysis.py
@/Users/samueledwards/ATSA_SEv2/routes/api.py

# Service to call
@/Users/samueledwards/ATSA_SEv2/services/joint_analysis_service.py

# Models for validation
@/Users/samueledwards/ATSA_SEv2/models/client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Joint Analysis Blueprint</name>
  <files>routes/joint_analysis.py</files>
  <action>
  Create blueprint with RESTful endpoints following pattern from routes/analysis.py (REQ-15).

  1. Create routes/joint_analysis.py with imports:
     ```python
     from flask import Blueprint, request, jsonify
     from models import db, Client, JointAnalysisSummary
     from services.joint_analysis_service import JointAnalysisService
     ```

  2. Create blueprint:
     ```python
     joint_analysis_bp = Blueprint('joint_analysis', __name__)
     ```

  3. Add GET endpoint for retrieving/triggering joint analysis:
     ```python
     @joint_analysis_bp.route('/analysis/joint/<int:spouse1_id>/<int:spouse2_id>', methods=['GET'])
     def get_joint_analysis(spouse1_id, spouse2_id):
         """
         Get joint analysis for two linked spouses.
         Returns cached result if available, otherwise triggers fresh analysis.

         REQ-15: Joint analysis API endpoint
         REQ-03: Returns three-column comparison (MFJ, MFS spouse1, MFS spouse2)

         Response:
         {
             'spouse1': {'summary': {...}, 'strategies': [...]},
             'spouse2': {'summary': {...}, 'strategies': [...]},
             'mfj': {'combined_income': ..., 'total_tax': ..., ...},
             'mfs_spouse1': {'income': ..., 'total_tax': ..., ...},
             'mfs_spouse2': {'income': ..., 'total_tax': ..., ...},
             'comparison': {
                 'recommended_status': 'MFJ' or 'MFS',
                 'savings_amount': ...,
                 'mfj_total_tax': ...,
                 'mfs_total_tax': ...,
                 'reason': ...,
                 'notes': [...]
             }
         }
         """
         # Validate clients exist
         spouse1 = Client.query.get_or_404(spouse1_id)
         spouse2 = Client.query.get_or_404(spouse2_id)

         # Validate spouse linkage
         if spouse1.spouse_id != spouse2_id or spouse2.spouse_id != spouse1_id:
             return jsonify({
                 'error': 'Clients are not linked as spouses',
                 'detail': f'Client {spouse1_id} spouse_id={spouse1.spouse_id}, Client {spouse2_id} spouse_id={spouse2.spouse_id}'
             }), 400

         try:
             # Delegate to service (uses cache if available)
             result = JointAnalysisService.analyze_joint(spouse1_id, spouse2_id, force_refresh=False)
             return jsonify(result), 200

         except ValueError as e:
             return jsonify({'error': str(e)}), 400
         except Exception as e:
             return jsonify({'error': 'Analysis failed', 'detail': str(e)}), 500
     ```

  4. Add POST endpoint for forcing refresh:
     ```python
     @joint_analysis_bp.route('/analysis/joint/<int:spouse1_id>/<int:spouse2_id>/refresh', methods=['POST'])
     def refresh_joint_analysis(spouse1_id, spouse2_id):
         """
         Force refresh joint analysis (bypass cache).

         Use when:
         - User uploaded new document
         - User manually triggered recalculation
         - Testing/debugging
         """
         # Validate clients exist
         spouse1 = Client.query.get_or_404(spouse1_id)
         spouse2 = Client.query.get_or_404(spouse2_id)

         # Validate spouse linkage
         if spouse1.spouse_id != spouse2_id or spouse2.spouse_id != spouse1_id:
             return jsonify({
                 'error': 'Clients are not linked as spouses'
             }), 400

         try:
             # Force fresh calculation
             result = JointAnalysisService.analyze_joint(spouse1_id, spouse2_id, force_refresh=True)
             return jsonify(result), 200

         except ValueError as e:
             return jsonify({'error': str(e)}), 400
         except Exception as e:
             return jsonify({'error': 'Analysis failed', 'detail': str(e)}), 500
     ```

  5. Add GET endpoint for comparison summary only (lightweight):
     ```python
     @joint_analysis_bp.route('/analysis/joint/<int:spouse1_id>/<int:spouse2_id>/summary', methods=['GET'])
     def get_joint_summary(spouse1_id, spouse2_id):
         """
         Get concise joint analysis summary (for dashboard/preview).

         Returns:
         {
             'mfj_tax': float,
             'mfs_tax': float,
             'recommended': 'MFJ' or 'MFS',
             'savings': float
         }
         """
         # Validate clients exist and are linked
         spouse1 = Client.query.get_or_404(spouse1_id)
         spouse2 = Client.query.get_or_404(spouse2_id)

         if spouse1.spouse_id != spouse2_id or spouse2.spouse_id != spouse1_id:
             return jsonify({'error': 'Clients are not linked as spouses'}), 400

         try:
             summary = JointAnalysisService.get_comparison_summary(spouse1_id, spouse2_id)
             return jsonify(summary), 200

         except ValueError as e:
             return jsonify({'error': str(e)}), 400
         except Exception as e:
             return jsonify({'error': 'Summary failed', 'detail': str(e)}), 500
     ```

  DO follow RESTful conventions: GET for retrieval, POST for actions.
  DO validate spouse linkage in every endpoint (defensive programming).
  DO use 400 for validation errors, 500 for unexpected errors.
  DO NOT put business logic in routes (delegate to JointAnalysisService).

  Why three endpoints:
  - GET /joint/<id>/<id> - Standard retrieval (uses cache)
  - POST /joint/<id>/<id>/refresh - Explicit refresh action
  - GET /joint/<id>/<id>/summary - Lightweight preview for dashboards

  Why spouse linkage validation: Prevents analysis of unrelated clients, ensures data integrity.
  </action>
  <verify>
  Start Flask app and test endpoints:
  ```bash
  flask run
  ```

  In another terminal:
  ```bash
  # Test GET (assumes clients 1 and 2 are linked spouses with data)
  curl http://localhost:5000/api/analysis/joint/1/2

  # Test POST refresh
  curl -X POST http://localhost:5000/api/analysis/joint/1/2/refresh

  # Test summary
  curl http://localhost:5000/api/analysis/joint/1/2/summary

  # Test validation (assumes clients 1 and 3 are NOT linked)
  curl http://localhost:5000/api/analysis/joint/1/3
  ```

  Expected: GET returns full JSON structure, POST returns fresh calculation, summary returns concise dict, validation returns 400 error.
  </verify>
  <done>
  - routes/joint_analysis.py created with joint_analysis_bp
  - GET /analysis/joint/<id>/<id> endpoint returns full comparison
  - POST /analysis/joint/<id>/<id>/refresh forces recalculation
  - GET /analysis/joint/<id>/<id>/summary returns concise comparison
  - All endpoints validate spouse linkage before analysis
  - Error handling with appropriate HTTP status codes
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Joint Analysis Blueprint</name>
  <files>routes/api.py</files>
  <action>
  Register joint_analysis_bp following pattern from routes/api.py lines 1-13.

  1. Add import after existing route imports (after line 5):
     ```python
     from routes.joint_analysis import joint_analysis_bp
     ```

  2. Register blueprint after existing registrations (after line 13):
     ```python
     api_bp.register_blueprint(joint_analysis_bp)
     ```

  DO maintain consistency with existing blueprint registration pattern.
  DO NOT modify existing blueprint registrations.

  Why this matters: api_bp is registered in app.py with url_prefix='/api'. Adding joint_analysis_bp here makes endpoints available at /api/analysis/joint/*.
  </action>
  <verify>
  Run Flask and check registered routes:
  ```bash
  python -c "from app import app; print([rule.rule for rule in app.url_map.iter_rules() if 'joint' in rule.rule])"
  ```

  Expected output includes:
  - /api/analysis/joint/<spouse1_id>/<spouse2_id>
  - /api/analysis/joint/<spouse1_id>/<spouse2_id>/refresh
  - /api/analysis/joint/<spouse1_id>/<spouse2_id>/summary
  </verify>
  <done>
  - routes/api.py imports joint_analysis_bp
  - routes/api.py registers joint_analysis_bp with api_bp
  - Joint analysis endpoints accessible at /api/analysis/joint/*
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Error Handling and Response Documentation</name>
  <files>routes/joint_analysis.py</files>
  <action>
  Enhance endpoints with comprehensive error handling and response examples.

  1. Add module docstring at top of file:
     ```python
     """
     Joint Analysis API Routes

     RESTful endpoints for dual-filer MFJ vs MFS tax analysis.

     Endpoints:
     - GET  /api/analysis/joint/<spouse1_id>/<spouse2_id>          - Get joint analysis (cached if available)
     - POST /api/analysis/joint/<spouse1_id>/<spouse2_id>/refresh - Force fresh analysis
     - GET  /api/analysis/joint/<spouse1_id>/<spouse2_id>/summary - Get concise summary

     Business Logic:
     All tax calculation logic is in JointAnalysisService. Routes are thin wrappers
     that validate input and delegate to service layer.

     Error Responses:
     - 400: Invalid input (clients not linked, missing data)
     - 404: Client not found
     - 500: Unexpected analysis failure

     Success Response (GET /joint/<id>/<id>):
     {
         'spouse1': {
             'summary': {
                 'total_income': float,
                 'adjusted_gross_income': float,
                 'taxable_income': float,
                 'total_tax': float,
                 ...
             },
             'strategies': [
                 {'strategy_name': str, 'potential_savings': float, ...},
                 ...
             ]
         },
         'spouse2': { ... },
         'mfj': {
             'combined_income': float,
             'agi': float,
             'standard_deduction': float,
             'taxable_income': float,
             'total_tax': float,
             'marginal_rate': float,
             'effective_rate': float
         },
         'mfs_spouse1': {
             'income': float,
             'agi': float,
             'standard_deduction': float,
             'taxable_income': float,
             'total_tax': float,
             'marginal_rate': float,
             'effective_rate': float
         },
         'mfs_spouse2': { ... },
         'comparison': {
             'recommended_status': 'MFJ' or 'MFS',
             'savings_amount': float,
             'mfj_total_tax': float,
             'mfs_total_tax': float,
             'reason': str,
             'notes': [
                 {'type': str, 'message': str, 'impact': str},
                 ...
             ]
         }
     }
     """
     ```

  2. Add helper function for consistent error responses:
     ```python
     def _validate_spouse_linkage(spouse1_id, spouse2_id):
         """
         Validate that two clients exist and are linked as spouses.

         Args:
             spouse1_id: First client ID
             spouse2_id: Second client ID

         Returns:
             tuple: (spouse1, spouse2) Client objects

         Raises:
             ValueError: If clients not found or not linked
         """
         spouse1 = Client.query.get(spouse1_id)
         spouse2 = Client.query.get(spouse2_id)

         if not spouse1:
             raise ValueError(f"Client {spouse1_id} not found")
         if not spouse2:
             raise ValueError(f"Client {spouse2_id} not found")

         if spouse1.spouse_id != spouse2_id:
             raise ValueError(
                 f"Client {spouse1_id} is not linked to client {spouse2_id}. "
                 f"Expected spouse_id={spouse2_id}, got spouse_id={spouse1.spouse_id}"
             )

         if spouse2.spouse_id != spouse1_id:
             raise ValueError(
                 f"Client {spouse2_id} is not linked to client {spouse1_id}. "
                 f"Expected spouse_id={spouse1_id}, got spouse_id={spouse2.spouse_id}"
             )

         return spouse1, spouse2
     ```

  3. Refactor endpoints to use helper:
     ```python
     # In get_joint_analysis():
     try:
         spouse1, spouse2 = _validate_spouse_linkage(spouse1_id, spouse2_id)
     except ValueError as e:
         return jsonify({'error': str(e)}), 400

     # ... rest of endpoint logic
     ```

  4. Add logging for debugging:
     ```python
     import logging

     logger = logging.getLogger(__name__)

     # In each endpoint, add:
     logger.info(f"Joint analysis requested for clients {spouse1_id} and {spouse2_id}")

     # On error:
     logger.error(f"Joint analysis failed: {str(e)}")
     ```

  DO provide clear error messages explaining what went wrong.
  DO use helper function to reduce code duplication.
  DO add logging for production debugging.

  Why comprehensive errors: Tax professional needs to understand why analysis failed (missing data vs wrong clients vs calculation error).
  </action>
  <verify>
  Test error scenarios:
  ```bash
  # Client not found
  curl http://localhost:5000/api/analysis/joint/999/1000

  # Clients not linked
  curl http://localhost:5000/api/analysis/joint/1/3

  # Valid request
  curl http://localhost:5000/api/analysis/joint/1/2
  ```

  Expected: 404 for not found, 400 for not linked with clear message, 200 for valid.
  </verify>
  <done>
  - Module docstring documents all endpoints and response format
  - _validate_spouse_linkage() helper reduces duplication
  - All endpoints use helper for consistent validation
  - Logging added for request tracking and error debugging
  - Error messages explain exactly what failed
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Test full API flow:
   ```bash
   # Start Flask app
   flask run

   # Test GET (uses cache if available)
   curl http://localhost:5000/api/analysis/joint/1/2 | jq '.comparison.recommended_status'

   # Test POST refresh (forces recalculation)
   curl -X POST http://localhost:5000/api/analysis/joint/1/2/refresh | jq '.mfj.total_tax'

   # Test summary (concise response)
   curl http://localhost:5000/api/analysis/joint/1/2/summary | jq '.recommended'
   ```

2. Test validation:
   ```bash
   # Non-existent client
   curl http://localhost:5000/api/analysis/joint/999/1000

   # Unlinked clients
   curl http://localhost:5000/api/analysis/joint/1/3

   # Valid linked spouses
   curl http://localhost:5000/api/analysis/joint/1/2
   ```

3. Test comparison structure (REQ-03):
   ```bash
   curl http://localhost:5000/api/analysis/joint/1/2 | jq '.comparison'
   ```
   Verify output includes:
   - recommended_status: 'MFJ' or 'MFS'
   - savings_amount: numeric
   - mfj_total_tax: numeric
   - mfs_total_tax: numeric
   - reason: string explanation
   - notes: array of comparison notes

4. Verify MFJ vs MFS values differ:
   ```bash
   curl http://localhost:5000/api/analysis/joint/1/2 | jq '{mfj: .mfj.standard_deduction, mfs: .mfs_spouse1.standard_deduction}'
   ```
   Expected: MFJ: 32200, MFS: 16100

5. Check response includes all three columns:
   ```bash
   curl http://localhost:5000/api/analysis/joint/1/2 | jq 'keys'
   ```
   Expected: ["comparison", "mfj", "mfs_spouse1", "mfs_spouse2", "spouse1", "spouse2"]
</verification>

<success_criteria>
1. GET /api/analysis/joint/<id>/<id> returns structured JSON with MFJ, MFS spouse1, MFS spouse2, and comparison (REQ-03, REQ-15)
2. POST /api/analysis/joint/<id>/<id>/refresh forces recalculation bypassing cache
3. GET /api/analysis/joint/<id>/<id>/summary returns concise comparison for dashboards
4. All endpoints validate spouse linkage and return 400 error for unlinked clients
5. Comparison section includes recommended_status, savings_amount, reason, and notes array
6. Blueprint registered in api.py and endpoints accessible at /api/analysis/joint/*
7. Error responses provide clear explanation of what failed
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-calculation-engine/01-04-SUMMARY.md`
</output>
