---
phase: 02-mfs-compliance-logic
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - services/joint_analysis_service.py
  - routes/joint_analysis.py
autonomous: true

must_haves:
  truths:
    - "When one MFS spouse itemizes, the other spouse is blocked from using standard deduction"
    - "MFJ vs MFS comparison shows SALT cap differences ($40.4k MFJ vs $20k each MFS)"
    - "Joint analysis supports both standard and itemized deduction paths"
    - "Deduction coordination errors are caught before joint analysis runs"
    - "Comparison notes explain itemized deduction differences between MFJ and MFS"
  artifacts:
    - path: "services/joint_analysis_service.py"
      provides: "Deduction coordination validation and itemized deduction support"
      contains: "validate_deduction_method_change"
      min_lines: 400
    - path: "routes/joint_analysis.py"
      provides: "Deduction coordination validation endpoint"
      contains: "/validate-deduction-method"
  key_links:
    - from: "services/joint_analysis_service.py"
      to: "services.ItemizedDeductionService"
      via: "call calculate_itemized_deductions"
      pattern: "ItemizedDeductionService\\.calculate_itemized_deductions"
    - from: "services/joint_analysis_service.py"
      to: "models.Client.deduction_method"
      via: "read deduction_method for coordination check"
      pattern: "deduction_method"
    - from: "routes/joint_analysis.py"
      to: "services.JointAnalysisService.validate_deduction_method_change"
      via: "API endpoint calls validation method"
      pattern: "validate_deduction_method_change"
---

<objective>
Complete MFS compliance implementation by adding deduction method coordination enforcement, extending joint analysis to support itemized deductions, and creating validation API endpoint.

Purpose: Enforce REQ-09 (deduction coordination: if one MFS spouse itemizes, both must itemize) and integrate itemized deduction calculation into joint analysis comparison, ensuring MFJ vs MFS comparison reflects true tax savings with correct SALT caps.

Output: Fully functional MFS compliance logic with coordination validation, itemized deduction path, and comparison showing SALT cap impact.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mfs-compliance-logic/02-RESEARCH.md
@.planning/LEARNINGS.md

# Prior plan outputs
@.planning/phases/02-mfs-compliance-logic/02-01-SUMMARY.md
@.planning/phases/02-mfs-compliance-logic/02-02-SUMMARY.md

# Existing files to modify
@services/joint_analysis_service.py
@routes/joint_analysis.py
@services/itemized_deduction_service.py
@models/client.py
</context>

<tasks>

<task type="auto">
  <name>Add deduction coordination validation to JointAnalysisService</name>
  <files>services/joint_analysis_service.py</files>
  <action>
Add two static methods to JointAnalysisService class (after existing methods, before analyze_joint):

**Method 1: validate_deduction_method_change(client_id, new_method)**

Implements REQ-09 deduction coordination rule for MFS.

Logic:
1. Load client by client_id
2. If filing_status != 'married_separate', return {'allowed': True, 'message': 'No coordination required', 'action': 'allow'}
3. If no spouse_id, return {'allowed': True, 'message': 'No spouse linked', 'action': 'allow'}
4. Load spouse by spouse_id
5. Check coordination:
   - If spouse.deduction_method == 'itemized' and new_method == 'standard':
     Return {'allowed': False, 'message': 'Cannot use standard deduction - spouse is itemizing. Both spouses must use the same deduction method when filing separately.', 'action': 'block', 'required_method': 'itemized'}
   - If new_method == 'itemized' and spouse.deduction_method == 'standard':
     Return {'allowed': True, 'message': 'Changing to itemized deductions will require spouse to also itemize.', 'action': 'confirm_cascade', 'cascade_to_spouse': True}
   - Otherwise:
     Return {'allowed': True, 'message': 'Coordination satisfied', 'action': 'allow'}

Reference implementation from RESEARCH.md lines 89-131 (Pattern 1).

**Method 2: check_mfs_deduction_coordination(spouse1_id, spouse2_id)**

Validation check called during joint analysis to ensure coordination before calculation.

Returns:
```python
{
    'valid': bool,
    'spouse1_method': str,
    'spouse2_method': str,
    'error': str or None
}
```

Logic:
1. Load both spouses
2. Verify both have filing_status == 'married_separate', else return valid=False with error
3. Compare deduction_method: if different, return valid=False with IRS rule message
4. If same, return valid=True

Reference implementation from RESEARCH.md lines 355-399.

Import ItemizedDeductionService at top of file: `from services.itemized_deduction_service import ItemizedDeductionService`
  </action>
  <verify>
```bash
cd /Users/samueledwards/ATSA_SEv2
# Verify methods exist
python -c "
from services.joint_analysis_service import JointAnalysisService
import sys
has_validate = hasattr(JointAnalysisService, 'validate_deduction_method_change')
has_check = hasattr(JointAnalysisService, 'check_mfs_deduction_coordination')
sys.exit(0 if (has_validate and has_check) else 1)
"
echo "Coordination methods exist"
```
Exit code 0 confirms both methods present.
  </verify>
  <done>JointAnalysisService has validate_deduction_method_change and check_mfs_deduction_coordination methods that enforce IRS deduction coordination rule for MFS filers</done>
</task>

<task type="auto">
  <name>Extend analyze_joint to support itemized deductions</name>
  <files>services/joint_analysis_service.py</files>
  <action>
Modify JointAnalysisService.analyze_joint() method to support itemized deduction path (currently hardcoded to standard deductions only).

Changes to make (reference existing analyze_joint method around lines 100-300):

**Step 1: Add coordination check (before MFJ calculation)**

After existing spouse validation (around line 140), add:
```python
# REQ-09: Check deduction method coordination for MFS
coordination = JointAnalysisService.check_mfs_deduction_coordination(spouse1_id, spouse2_id)
if not coordination['valid']:
    raise ValueError(f"Deduction coordination error: {coordination['error']}")
```

**Step 2: Extend MFJ calculation (around line 200)**

Replace hardcoded standard deduction lookup with:
```python
deduction_method = spouse1.deduction_method  # Same for both (coordination enforced)

if deduction_method == 'itemized':
    # Calculate itemized deductions for MFJ
    # Combine both spouses' itemized amounts
    spouse1_itemized = ItemizedDeductionService.calculate_itemized_deductions(spouse1_id, tax_year)
    spouse2_itemized = ItemizedDeductionService.calculate_itemized_deductions(spouse2_id, tax_year)

    # For MFJ, combine raw amounts and recalculate with MFJ SALT cap
    combined_salt = (spouse1_itemized['breakdown']['state_local_taxes']['raw'] +
                     spouse2_itemized['breakdown']['state_local_taxes']['raw'])
    combined_medical = (spouse1_itemized['breakdown']['medical_expenses']['raw'] +
                        spouse2_itemized['breakdown']['medical_expenses']['raw'])
    combined_mortgage = (spouse1_itemized['breakdown']['mortgage_interest'] +
                         spouse2_itemized['breakdown']['mortgage_interest'])
    combined_charitable = (spouse1_itemized['breakdown']['charitable_contributions'] +
                           spouse2_itemized['breakdown']['charitable_contributions'])

    # Apply MFJ SALT cap ($40,400) to combined SALT
    mfj_salt = ItemizedDeductionService.calculate_salt_deduction(
        state_local_taxes=combined_salt,
        filing_status='married_joint',
        magi=combined_agi,  # Use combined AGI for MFJ
        tax_year=tax_year
    )

    # Medical threshold uses combined AGI for MFJ
    medical_threshold = combined_agi * 0.075
    medical_deductible = max(0, combined_medical - medical_threshold)

    mfj_itemized_total = (medical_deductible +
                          mfj_salt['deduction_allowed'] +
                          combined_mortgage +
                          combined_charitable)

    mfj_standard = TaxCalculator.get_standard_deduction('married_joint', 'federal', tax_year=tax_year)
    mfj_deduction = max(mfj_itemized_total, mfj_standard)
    mfj_use_itemized = mfj_itemized_total > mfj_standard
else:
    # Use standard deduction (existing path)
    mfj_deduction = TaxCalculator.get_standard_deduction('married_joint', 'federal', tax_year=tax_year)
    mfj_use_itemized = False
```

**Step 3: Extend MFS calculation (around line 250)**

Replace hardcoded standard deduction with:
```python
if deduction_method == 'itemized':
    # Each spouse calculates itemized separately with MFS SALT cap ($20k each)
    spouse1_itemized_result = ItemizedDeductionService.calculate_itemized_deductions(spouse1_id, tax_year)
    mfs_spouse1_deduction = spouse1_itemized_result['itemized_total']
    mfs_spouse1_use_itemized = spouse1_itemized_result['use_itemized']

    spouse2_itemized_result = ItemizedDeductionService.calculate_itemized_deductions(spouse2_id, tax_year)
    mfs_spouse2_deduction = spouse2_itemized_result['itemized_total']
    mfs_spouse2_use_itemized = spouse2_itemized_result['use_itemized']
else:
    # Both use standard (existing path)
    mfs_std_deduction = TaxCalculator.get_standard_deduction('married_separate', 'federal', tax_year=tax_year)
    mfs_spouse1_deduction = mfs_std_deduction
    mfs_spouse2_deduction = mfs_std_deduction
    mfs_spouse1_use_itemized = False
    mfs_spouse2_use_itemized = False
```

**Step 4: Add itemized notes to comparison_notes (around line 320)**

After existing comparison notes, add:
```python
if deduction_method == 'itemized':
    comparison_notes.append({
        'type': 'deduction_coordination',
        'message': 'Both spouses itemizing (IRS requirement for MFS)',
        'impact': f'MFJ itemized: ${mfj_deduction:,.2f} | MFS combined: ${mfs_spouse1_deduction + mfs_spouse2_deduction:,.2f}'
    })

    # Add SALT cap note if SALT was capped
    if mfs_spouse1_use_itemized or mfs_spouse2_use_itemized:
        comparison_notes.append({
            'type': 'salt_cap_difference',
            'message': 'SALT cap differs by filing status',
            'impact': f'MFJ cap: $40,400 | MFS cap: $20,000 each spouse'
        })
```

Critical: Use exact filing status strings ('married_joint', 'married_separate') matching TaxCalculator. Calculate MAGI for phase-out by getting AGI from AnalysisResult or calculating from income sources. Use Decimal for calculations, round at display.
  </action>
  <verify>
```bash
cd /Users/samueledwards/ATSA_SEv2
# Verify analyze_joint imports ItemizedDeductionService
python -c "
import inspect
from services.joint_analysis_service import JointAnalysisService
source = inspect.getsource(JointAnalysisService.analyze_joint)
assert 'ItemizedDeductionService' in source or 'itemized' in source.lower(), 'analyze_joint should reference itemized deductions'
print('analyze_joint includes itemized logic')
"
```
Confirms method modified to support itemized path.
  </verify>
  <done>JointAnalysisService.analyze_joint supports both standard and itemized deduction paths, enforces coordination, applies correct SALT caps ($40.4k MFJ, $20k per MFS spouse), and adds itemized deduction notes to comparison output</done>
</task>

<task type="auto">
  <name>Add deduction method validation API endpoint</name>
  <files>routes/joint_analysis.py</files>
  <action>
Add new route to joint_analysis blueprint for deduction method validation (REQ-09 UI integration).

Add route after existing routes (around line 60):

```python
@joint_analysis_bp.route('/validate-deduction-method', methods=['POST'])
def validate_deduction_method():
    """
    Validate deduction method change for MFS coordination.

    Request body:
    {
        "client_id": int,
        "new_method": "standard" or "itemized"
    }

    Response:
    {
        "allowed": bool,
        "message": str,
        "action": "allow" | "block" | "confirm_cascade",
        "required_method": str (if blocked),
        "cascade_to_spouse": bool (if confirm_cascade)
    }
    """
    try:
        data = request.get_json()
        client_id = data.get('client_id')
        new_method = data.get('new_method')

        # Validate inputs
        if not client_id or not new_method:
            return jsonify({'error': 'client_id and new_method required'}), 400

        if new_method not in ['standard', 'itemized']:
            return jsonify({'error': 'new_method must be "standard" or "itemized"'}), 400

        # Call validation service
        result = JointAnalysisService.validate_deduction_method_change(client_id, new_method)

        return jsonify(result), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

This endpoint enables UI to validate deduction method changes before saving, displaying blocking messages or cascade confirmations to user.

Ensure `from flask import request, jsonify` imports exist at top of file (should already be present from existing routes).
  </action>
  <verify>
```bash
cd /Users/samueledwards/ATSA_SEv2
# Test endpoint exists (app context required)
python -c "
from app import app
with app.app_context():
    from routes.joint_analysis import joint_analysis_bp
    rules = [str(rule) for rule in joint_analysis_bp.url_map.iter_rules()]
    assert any('validate-deduction-method' in rule for rule in rules), 'Validation endpoint not found'
    print('Validation endpoint registered')
" 2>&1 | grep -E "(registered|error)" || echo "Check requires running app"

# Verify route defined
grep -n "validate-deduction-method" /Users/samueledwards/ATSA_SEv2/routes/joint_analysis.py
```
Endpoint definition found in file confirms addition.
  </verify>
  <done>API endpoint POST /api/joint-analysis/validate-deduction-method exists, accepts client_id and new_method, returns validation result with allowed/blocked/cascade action for UI consumption</done>
</task>

</tasks>

<verification>
Final verification checks:

1. JointAnalysisService.validate_deduction_method_change blocks standard when spouse itemizes
2. JointAnalysisService.check_mfs_deduction_coordination enforces same method for both MFS spouses
3. JointAnalysisService.analyze_joint supports itemized deduction path with correct SALT caps
4. MFJ calculation uses $40,400 SALT cap, MFS uses $20,000 per spouse
5. API endpoint /validate-deduction-method returns coordination validation results
6. Comparison notes include deduction coordination and SALT cap differences
</verification>

<success_criteria>
1. When one MFS spouse has deduction_method='itemized', validate_deduction_method_change blocks the other spouse from using 'standard' and displays IRS coordination rule message
2. California couple with $60k combined SALT filing MFS sees $20k cap per spouse ($40k total), filing MFJ sees $40,400 cap - the difference appears in comparison notes
3. Joint analysis with itemized deductions completes without errors and shows itemized vs standard for both MFJ and MFS scenarios
4. API validation endpoint returns 400 for invalid inputs, 200 with validation result for valid requests
5. Coordination check raises ValueError if spouses have mismatched deduction methods during analyze_joint call
</success_criteria>

<output>
After completion, create `.planning/phases/02-mfs-compliance-logic/02-03-SUMMARY.md`
</output>
