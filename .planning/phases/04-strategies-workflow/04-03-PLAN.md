---
phase: 04-strategies-workflow
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - services/tax_strategies.py
  - static/js/joint_analysis.js
autonomous: true

must_haves:
  truths:
    - "System detects income type from extracted data (W-2 = employee, Schedule C = self-employed)"
    - "LLC owner sees SEP-IRA and QBI strategies prioritized"
    - "W-2 employee sees 401(k) and HSA strategies prioritized"
    - "Per-spouse strategies displayed in joint analysis spouse panels"
  artifacts:
    - path: "services/tax_strategies.py"
      provides: "Income type detection and strategy relevance filtering"
      contains: "detect_income_types"
    - path: "static/js/joint_analysis.js"
      provides: "Per-spouse strategy rendering in panels"
      contains: "renderSpouseStrategies"
  key_links:
    - from: "services/tax_strategies.py"
      to: "ExtractedData"
      via: "query form_types to detect income types"
      pattern: "ExtractedData.*form_type.*distinct"
    - from: "static/js/joint_analysis.js"
      to: "API response"
      via: "display strategies from spouse1/spouse2 data"
      pattern: "data\\.spouse.*strategies"
---

<objective>
Add income-type-aware strategy recommendations so each spouse sees personalized strategies.

Purpose: Currently all strategies are analyzed generically. This plan adds income type detection (W-2, LLC/Schedule C, rental, etc.) and prioritizes relevant strategies for each spouse based on their income profile.

Output: TaxStrategiesService with income type detection, strategy relevance filtering, and UI display in joint analysis spouse panels.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-strategies-workflow/04-RESEARCH.md
@.planning/phases/04-strategies-workflow/04-02-SUMMARY.md

# Key existing code
# services/tax_strategies.py - TaxStrategiesService with 10 strategies
# services/joint_analysis_service.py - returns spouse1/spouse2 strategies
# static/js/joint_analysis.js - displaySpouseSummary renders panels
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add income type detection to TaxStrategiesService</name>
  <files>services/tax_strategies.py</files>
  <action>
Add income type detection and strategy relevance mapping to services/tax_strategies.py:

1. Add income type to strategy mapping constant after existing constants (around line 45):
   ```python
   # Income type to relevant strategies mapping
   INCOME_TYPE_STRATEGIES = {
       'w2_employee': [
           'retirement_contributions',  # 401(k) via employer
           # HSA, FSA typically employer-provided
       ],
       'self_employed': [
           'retirement_contributions',  # SEP-IRA, Solo 401(k)
           'qbi_deduction',
           'se_tax_deduction',
           'se_health_insurance',
           'home_office'
       ],
       'business_owner': [
           'qbi_deduction',
           'section_179',
           'bonus_depreciation',
           'rd_deduction',
           'fmla_credit'
       ],
       'rental_income': [
           'section_179',
           'bonus_depreciation'
       ],
       'capital_gains': [
           'qsbs_exclusion'
       ]
   }
   ```

2. Add detect_income_types static method to TaxStrategiesService class (after __init__ or as first method):
   ```python
   @staticmethod
   def detect_income_types(client_id):
       """
       Detect income types from client's extracted data based on form types present.

       Args:
           client_id: Client ID to check

       Returns:
           list: Income type strings (e.g., ['w2_employee', 'self_employed'])
       """
       from models import ExtractedData
       from models import db

       # Query distinct form types for this client
       forms = db.session.query(ExtractedData.form_type).filter_by(
           client_id=client_id
       ).distinct().all()
       form_types = {f[0] for f in forms if f[0]}

       income_types = []

       if 'W-2' in form_types:
           income_types.append('w2_employee')
       if 'Schedule C' in form_types:
           income_types.append('self_employed')
       if 'Schedule E' in form_types:
           income_types.append('rental_income')
       if 'K-1' in form_types:
           income_types.append('business_owner')
       if 'Schedule D' in form_types or 'Form 8949' in form_types:
           income_types.append('capital_gains')
       if '1099-INT' in form_types or '1099-DIV' in form_types:
           income_types.append('investment_income')

       return income_types if income_types else ['unknown']
   ```

3. Add filter_strategies_by_income_type static method:
   ```python
   @staticmethod
   def filter_strategies_by_income_type(strategies, income_types):
       """
       Prioritize strategies relevant to detected income types.

       Moves relevant strategies to front of list, others follow.

       Args:
           strategies: List of AnalysisResult objects
           income_types: List of income type strings

       Returns:
           list: Sorted strategies with relevant ones first
       """
       import json

       # Build set of relevant strategy IDs
       relevant_ids = set()
       for income_type in income_types:
           relevant_ids.update(TaxStrategiesService.INCOME_TYPE_STRATEGIES.get(income_type, []))

       def get_relevance_key(strategy):
           """Sort key: relevant strategies first, then by priority"""
           try:
               # Parse detailed_info from strategy_description JSON
               info = json.loads(strategy.strategy_description)
               strategy_id = info.get('strategy_id', '')
               is_relevant = strategy_id in relevant_ids
               return (0 if is_relevant else 1, strategy.priority)
           except (json.JSONDecodeError, AttributeError):
               return (1, strategy.priority)

       return sorted(strategies, key=get_relevance_key)
   ```

4. Add get_personalized_strategies static method that combines analyze_all with income filtering:
   ```python
   @staticmethod
   def get_personalized_strategies(data_by_form, client):
       """
       Get strategies personalized to client's income type.

       Analyzes all strategies, then prioritizes by income type relevance.

       Args:
           data_by_form: Dictionary of form data
           client: Client model instance

       Returns:
           tuple: (strategies_list, income_types_list)
       """
       # Detect income types
       income_types = TaxStrategiesService.detect_income_types(client.id)

       # Analyze all strategies
       strategies = TaxStrategiesService.analyze_all_strategies(data_by_form, client)

       # Filter/prioritize by income type
       prioritized = TaxStrategiesService.filter_strategies_by_income_type(strategies, income_types)

       return prioritized, income_types
   ```

Note: These methods work with existing analyze_all_strategies without modifying it.
  </action>
  <verify>
Test income type detection:
```python
from services.tax_strategies import TaxStrategiesService
# Assuming client ID 1 exists with some extracted data
types = TaxStrategiesService.detect_income_types(1)
print(types)  # Should return list like ['w2_employee'] or ['self_employed']
```
  </verify>
  <done>
TaxStrategiesService has detect_income_types, filter_strategies_by_income_type, and get_personalized_strategies methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate income-type detection into joint analysis response</name>
  <files>services/joint_analysis_service.py</files>
  <action>
Modify JointAnalysisService.analyze_joint() to include income types in response.

Find the section that builds the return dict (around line 663) and add income_types to spouse data:

1. After analyzing each spouse (around line 390-391), also get income types:
   ```python
   # Step 4: Analyze each spouse individually
   spouse1_strategies, spouse1_summary = AnalysisEngine.analyze_client(spouse1_id)
   spouse2_strategies, spouse2_summary = AnalysisEngine.analyze_client(spouse2_id)

   # Detect income types for personalization
   from services.tax_strategies import TaxStrategiesService
   spouse1_income_types = TaxStrategiesService.detect_income_types(spouse1_id)
   spouse2_income_types = TaxStrategiesService.detect_income_types(spouse2_id)

   # Prioritize strategies by income type
   spouse1_strategies = TaxStrategiesService.filter_strategies_by_income_type(
       spouse1_strategies, spouse1_income_types
   )
   spouse2_strategies = TaxStrategiesService.filter_strategies_by_income_type(
       spouse2_strategies, spouse2_income_types
   )
   ```

2. Update the return dict to include income_types (around line 663):
   ```python
   return {
       'spouse1': {
           'summary': spouse1_summary,
           'strategies': [s.to_dict() for s in spouse1_strategies],
           'income_types': spouse1_income_types  # NEW
       },
       'spouse2': {
           'summary': spouse2_summary,
           'strategies': [s.to_dict() for s in spouse2_strategies],
           'income_types': spouse2_income_types  # NEW
       },
       # ... rest unchanged
   }
   ```

3. Also update _format_cached_result to include income_types (around line 284):
   ```python
   @staticmethod
   def _format_cached_result(cached, spouse1_id, spouse2_id):
       """Format cached JointAnalysisSummary into return structure"""
       spouse1_strategies, spouse1_summary = AnalysisEngine.analyze_client(spouse1_id)
       spouse2_strategies, spouse2_summary = AnalysisEngine.analyze_client(spouse2_id)

       # Get income types for cached results too
       from services.tax_strategies import TaxStrategiesService
       spouse1_income_types = TaxStrategiesService.detect_income_types(spouse1_id)
       spouse2_income_types = TaxStrategiesService.detect_income_types(spouse2_id)

       # Prioritize strategies
       spouse1_strategies = TaxStrategiesService.filter_strategies_by_income_type(
           spouse1_strategies, spouse1_income_types
       )
       spouse2_strategies = TaxStrategiesService.filter_strategies_by_income_type(
           spouse2_strategies, spouse2_income_types
       )

       # ... rest of formatting ...

       return {
           'spouse1': {
               'summary': spouse1_summary,
               'strategies': [s.to_dict() for s in spouse1_strategies],
               'income_types': spouse1_income_types
           },
           'spouse2': {
               'summary': spouse2_summary,
               'strategies': [s.to_dict() for s in spouse2_strategies],
               'income_types': spouse2_income_types
           },
           # ... rest unchanged
       }
   ```
  </action>
  <verify>
Test API response:
```bash
curl http://localhost:5001/api/joint-analysis/1/2 | python -m json.tool | grep -A5 income_types
```
Should show income_types array for each spouse.
  </verify>
  <done>
Joint analysis API returns income_types array for each spouse and strategies are prioritized by income relevance.
  </done>
</task>

<task type="auto">
  <name>Task 3: Display per-spouse strategies in joint analysis UI</name>
  <files>static/js/joint_analysis.js</files>
  <action>
Update static/js/joint_analysis.js to render strategies in spouse panels:

1. Add renderSpouseStrategies function (after displaySpouseSummary function around line 306):
   ```javascript
   /**
    * Render strategy recommendations for a spouse.
    * @param {Array} strategies - Strategy objects from API
    * @param {Array} incomeTypes - Income type strings (e.g., ['self_employed'])
    * @returns {string} HTML for strategies section
    */
   function renderSpouseStrategies(strategies, incomeTypes) {
       if (!strategies || strategies.length === 0) {
           return '<p class="no-data">No strategies analyzed yet</p>';
       }

       // Format income types for display
       const incomeTypeLabels = {
           'w2_employee': 'W-2 Employee',
           'self_employed': 'Self-Employed',
           'business_owner': 'Business Owner',
           'rental_income': 'Rental Income',
           'capital_gains': 'Capital Gains',
           'investment_income': 'Investment Income',
           'unknown': 'Unknown'
       };

       const incomeTypesDisplay = (incomeTypes || [])
           .map(t => incomeTypeLabels[t] || t)
           .join(', ');

       // Build strategy cards HTML
       const strategiesHtml = strategies.slice(0, 5).map(strategy => {
           const info = parseStrategyInfo(strategy);
           const statusClass = getStatusClass(info.status);
           const isRelevant = isStrategyRelevant(info.strategy_id, incomeTypes);

           return `
               <div class="strategy-item ${statusClass} ${isRelevant ? 'relevant' : ''}">
                   <div class="strategy-header">
                       <span class="strategy-name">${strategy.strategy_name}</span>
                       ${isRelevant ? '<span class="relevance-badge">Recommended</span>' : ''}
                   </div>
                   <div class="strategy-status">${formatStatus(info.status)}</div>
                   ${info.recommendations && info.recommendations.length > 0 ?
                       `<ul class="strategy-recommendations">
                           ${info.recommendations.slice(0, 2).map(r => `<li>${r}</li>`).join('')}
                       </ul>` : ''
                   }
               </div>
           `;
       }).join('');

       return `
           <div class="spouse-strategies">
               <h4>Tax Strategies</h4>
               <div class="income-type-badge">Income: ${incomeTypesDisplay || 'Not detected'}</div>
               <div class="strategies-list">
                   ${strategiesHtml}
               </div>
           </div>
       `;
   }
   ```

2. Add helper functions:
   ```javascript
   /**
    * Parse strategy info from strategy_description JSON
    */
   function parseStrategyInfo(strategy) {
       try {
           return JSON.parse(strategy.strategy_description || '{}');
       } catch (e) {
           return { status: 'UNKNOWN', recommendations: [] };
       }
   }

   /**
    * Get CSS class for strategy status
    */
   function getStatusClass(status) {
       const statusClasses = {
           'FULLY_UTILIZED': 'status-good',
           'PARTIALLY_UTILIZED': 'status-partial',
           'NOT_UTILIZED': 'status-warning',
           'POTENTIALLY_MISSED': 'status-warning',
           'NOT_APPLICABLE': 'status-neutral',
           'ERROR_DETECTED': 'status-error'
       };
       return statusClasses[status] || 'status-neutral';
   }

   /**
    * Format status for display
    */
   function formatStatus(status) {
       const statusLabels = {
           'FULLY_UTILIZED': 'Fully Utilized',
           'PARTIALLY_UTILIZED': 'Partially Utilized',
           'NOT_UTILIZED': 'Not Used',
           'POTENTIALLY_MISSED': 'Potential Opportunity',
           'NOT_APPLICABLE': 'N/A',
           'ERROR_DETECTED': 'Review Needed'
       };
       return statusLabels[status] || status;
   }

   /**
    * Check if strategy is relevant to income types
    */
   function isStrategyRelevant(strategyId, incomeTypes) {
       const INCOME_TYPE_STRATEGIES = {
           'w2_employee': ['retirement_contributions'],
           'self_employed': ['retirement_contributions', 'qbi_deduction', 'se_tax_deduction', 'se_health_insurance', 'home_office'],
           'business_owner': ['qbi_deduction', 'section_179', 'bonus_depreciation', 'rd_deduction', 'fmla_credit'],
           'rental_income': ['section_179', 'bonus_depreciation'],
           'capital_gains': ['qsbs_exclusion']
       };

       return (incomeTypes || []).some(type => {
           const relevantStrategies = INCOME_TYPE_STRATEGIES[type] || [];
           return relevantStrategies.includes(strategyId);
       });
   }
   ```

3. Update displaySpouseSummary to include strategies (modify the function around line 248):
   Find where contentEl.innerHTML is set and add the strategies section:
   ```javascript
   // After the existing spouse-summary-grid div, add:
   const strategiesHtml = renderSpouseStrategies(data.strategies, data.income_types);

   contentEl.innerHTML = `
       <div class="income-breakdown">
           ...existing content...
       </div>

       <div class="spouse-summary-grid">
           ...existing cards...
       </div>

       ${strategiesHtml}
   `;
   ```

4. Add CSS for strategy display (add to style block or reference):
   Note: This CSS should be added to static/css/style.css or inline in joint_analysis.html

   ```css
   .spouse-strategies {
       margin-top: 1.5rem;
       padding-top: 1rem;
       border-top: 1px solid #eee;
   }

   .spouse-strategies h4 {
       margin-bottom: 0.5rem;
       font-size: 1rem;
   }

   .income-type-badge {
       font-size: 0.85rem;
       color: #666;
       margin-bottom: 1rem;
   }

   .strategies-list {
       display: flex;
       flex-direction: column;
       gap: 0.75rem;
   }

   .strategy-item {
       padding: 0.75rem;
       border-radius: 4px;
       background: #f9f9f9;
       border-left: 3px solid #ddd;
   }

   .strategy-item.relevant {
       border-left-color: #4caf50;
       background: #f1f8e9;
   }

   .strategy-item.status-good {
       border-left-color: #4caf50;
   }

   .strategy-item.status-partial {
       border-left-color: #ff9800;
   }

   .strategy-item.status-warning {
       border-left-color: #f44336;
   }

   .strategy-header {
       display: flex;
       justify-content: space-between;
       align-items: center;
   }

   .strategy-name {
       font-weight: 500;
       font-size: 0.9rem;
   }

   .relevance-badge {
       font-size: 0.75rem;
       padding: 2px 6px;
       background: #4caf50;
       color: white;
       border-radius: 3px;
   }

   .strategy-status {
       font-size: 0.8rem;
       color: #666;
       margin-top: 0.25rem;
   }

   .strategy-recommendations {
       margin: 0.5rem 0 0 1rem;
       padding: 0;
       font-size: 0.8rem;
       color: #555;
   }

   .strategy-recommendations li {
       margin-bottom: 0.25rem;
   }
   ```
  </action>
  <verify>
1. Navigate to http://localhost:5001/joint-analysis.html
2. Select two linked spouses with different income types (one with W-2 data, one with Schedule C)
3. Load analysis
4. Verify each spouse panel shows "Tax Strategies" section
5. Verify strategies show "Recommended" badge when relevant to income type
6. Verify LLC owner spouse shows QBI, SEP-IRA strategies prioritized
7. Verify W-2 employee spouse shows retirement contributions prioritized
  </verify>
  <done>
Joint analysis UI displays per-spouse strategies with income type badges and relevance highlighting.
  </done>
</task>

</tasks>

<verification>
1. Income detection: Create test client with W-2 data -> detect_income_types returns ['w2_employee']

2. Income detection: Create test client with Schedule C data -> detect_income_types returns ['self_employed']

3. Strategy prioritization: Self-employed client has QBI, SEP-IRA strategies first in list

4. API response: GET /api/joint-analysis/{id1}/{id2} includes income_types in spouse1 and spouse2 objects

5. UI display: Spouse panels show strategies with income type labels and relevance badges
</verification>

<success_criteria>
- detect_income_types correctly identifies W-2, Schedule C, K-1, Schedule E form presence
- filter_strategies_by_income_type moves relevant strategies to front of list
- Joint analysis API includes income_types in response
- UI shows "Income: Self-Employed" or "Income: W-2 Employee" per spouse
- UI shows "Recommended" badge on income-relevant strategies
- Husband with LLC income sees SEP-IRA, QBI prioritized
- Wife with W-2 income sees 401(k)/retirement prioritized
</success_criteria>

<output>
After completion, create `.planning/phases/04-strategies-workflow/04-03-SUMMARY.md`
</output>
